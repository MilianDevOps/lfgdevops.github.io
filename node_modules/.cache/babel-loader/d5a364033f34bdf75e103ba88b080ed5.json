{"ast":null,"code":"import { Camera } from './Camera.js';\nimport * as MathUtils from '../math/MathUtils.js';\n\nclass PerspectiveCamera extends Camera {\n  constructor() {\n    let fov = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    let aspect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n    let far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2000;\n    super();\n    this.type = 'PerspectiveCamera';\n    this.fov = fov;\n    this.zoom = 1;\n    this.near = near;\n    this.far = far;\n    this.focus = 10;\n    this.aspect = aspect;\n    this.view = null;\n    this.filmGauge = 35; // width of the film (default in millimeters)\n\n    this.filmOffset = 0; // horizontal film offset (same unit as gauge)\n\n    this.updateProjectionMatrix();\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.fov = source.fov;\n    this.zoom = source.zoom;\n    this.near = source.near;\n    this.far = source.far;\n    this.focus = source.focus;\n    this.aspect = source.aspect;\n    this.view = source.view === null ? null : Object.assign({}, source.view);\n    this.filmGauge = source.filmGauge;\n    this.filmOffset = source.filmOffset;\n    return this;\n  }\n  /**\n   * Sets the FOV by focal length in respect to the current .filmGauge.\n   *\n   * The default film gauge is 35, so that the focal length can be specified for\n   * a 35mm (full frame) camera.\n   *\n   * Values for focal length and film gauge must have the same unit.\n   */\n\n\n  setFocalLength(focalLength) {\n    /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);\n    this.updateProjectionMatrix();\n  }\n  /**\n   * Calculates the focal length from the current .fov and .filmGauge.\n   */\n\n\n  getFocalLength() {\n    const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);\n    return 0.5 * this.getFilmHeight() / vExtentSlope;\n  }\n\n  getEffectiveFOV() {\n    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);\n  }\n\n  getFilmWidth() {\n    // film not completely covered in portrait format (aspect < 1)\n    return this.filmGauge * Math.min(this.aspect, 1);\n  }\n\n  getFilmHeight() {\n    // film not completely covered in landscape format (aspect > 1)\n    return this.filmGauge / Math.max(this.aspect, 1);\n  }\n  /**\n   * Sets an offset in a larger frustum. This is useful for multi-window or\n   * multi-monitor/multi-machine setups.\n   *\n   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n   * the monitors are in grid like this\n   *\n   *   +---+---+---+\n   *   | A | B | C |\n   *   +---+---+---+\n   *   | D | E | F |\n   *   +---+---+---+\n   *\n   * then for each monitor you would call it like this\n   *\n   *   const w = 1920;\n   *   const h = 1080;\n   *   const fullWidth = w * 3;\n   *   const fullHeight = h * 2;\n   *\n   *   --A--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n   *   --B--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n   *   --C--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n   *   --D--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n   *   --E--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n   *   --F--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n   *\n   *   Note there is no reason monitors have to be the same size or in a grid.\n   */\n\n\n  setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n    this.aspect = fullWidth / fullHeight;\n\n    if (this.view === null) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1\n      };\n    }\n\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n    this.updateProjectionMatrix();\n  }\n\n  clearViewOffset() {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n\n    this.updateProjectionMatrix();\n  }\n\n  updateProjectionMatrix() {\n    const near = this.near;\n    let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;\n    let height = 2 * top;\n    let width = this.aspect * height;\n    let left = -0.5 * width;\n    const view = this.view;\n\n    if (this.view !== null && this.view.enabled) {\n      const fullWidth = view.fullWidth,\n            fullHeight = view.fullHeight;\n      left += view.offsetX * width / fullWidth;\n      top -= view.offsetY * height / fullHeight;\n      width *= view.width / fullWidth;\n      height *= view.height / fullHeight;\n    }\n\n    const skew = this.filmOffset;\n    if (skew !== 0) left += near * skew / this.getFilmWidth();\n    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.fov = this.fov;\n    data.object.zoom = this.zoom;\n    data.object.near = this.near;\n    data.object.far = this.far;\n    data.object.focus = this.focus;\n    data.object.aspect = this.aspect;\n    if (this.view !== null) data.object.view = Object.assign({}, this.view);\n    data.object.filmGauge = this.filmGauge;\n    data.object.filmOffset = this.filmOffset;\n    return data;\n  }\n\n}\n\nPerspectiveCamera.prototype.isPerspectiveCamera = true;\nexport { PerspectiveCamera };","map":null,"metadata":{},"sourceType":"module"}