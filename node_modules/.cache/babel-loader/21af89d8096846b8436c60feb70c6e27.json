{"ast":null,"code":"import _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Vector2 } from '../../math/Vector2.js';\nimport { CurvePath } from './CurvePath.js';\nimport { EllipseCurve } from '../curves/EllipseCurve.js';\nimport { SplineCurve } from '../curves/SplineCurve.js';\nimport { CubicBezierCurve } from '../curves/CubicBezierCurve.js';\nimport { QuadraticBezierCurve } from '../curves/QuadraticBezierCurve.js';\nimport { LineCurve } from '../curves/LineCurve.js';\n\nvar Path = /*#__PURE__*/function (_CurvePath) {\n  _inherits(Path, _CurvePath);\n\n  var _super = _createSuper(Path);\n\n  function Path(points) {\n    var _this;\n\n    _classCallCheck(this, Path);\n\n    _this = _super.call(this);\n    _this.type = 'Path';\n    _this.currentPoint = new Vector2();\n\n    if (points) {\n      _this.setFromPoints(points);\n    }\n\n    return _this;\n  }\n\n  _createClass(Path, [{\n    key: \"setFromPoints\",\n    value: function setFromPoints(points) {\n      this.moveTo(points[0].x, points[0].y);\n\n      for (var i = 1, l = points.length; i < l; i++) {\n        this.lineTo(points[i].x, points[i].y);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(x, y) {\n      this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?\n\n      return this;\n    }\n  }, {\n    key: \"lineTo\",\n    value: function lineTo(x, y) {\n      var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));\n      this.curves.push(curve);\n      this.currentPoint.set(x, y);\n      return this;\n    }\n  }, {\n    key: \"quadraticCurveTo\",\n    value: function quadraticCurveTo(aCPx, aCPy, aX, aY) {\n      var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));\n      this.curves.push(curve);\n      this.currentPoint.set(aX, aY);\n      return this;\n    }\n  }, {\n    key: \"bezierCurveTo\",\n    value: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n      var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));\n      this.curves.push(curve);\n      this.currentPoint.set(aX, aY);\n      return this;\n    }\n  }, {\n    key: \"splineThru\",\n    value: function splineThru(pts\n    /*Array of Vector*/\n    ) {\n      var npts = [this.currentPoint.clone()].concat(pts);\n      var curve = new SplineCurve(npts);\n      this.curves.push(curve);\n      this.currentPoint.copy(pts[pts.length - 1]);\n      return this;\n    }\n  }, {\n    key: \"arc\",\n    value: function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n      var x0 = this.currentPoint.x;\n      var y0 = this.currentPoint.y;\n      this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\n      return this;\n    }\n  }, {\n    key: \"absarc\",\n    value: function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n      this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n      return this;\n    }\n  }, {\n    key: \"ellipse\",\n    value: function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n      var x0 = this.currentPoint.x;\n      var y0 = this.currentPoint.y;\n      this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n      return this;\n    }\n  }, {\n    key: \"absellipse\",\n    value: function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n      var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n\n      if (this.curves.length > 0) {\n        // if a previous curve is present, attempt to join\n        var firstPoint = curve.getPoint(0);\n\n        if (!firstPoint.equals(this.currentPoint)) {\n          this.lineTo(firstPoint.x, firstPoint.y);\n        }\n      }\n\n      this.curves.push(curve);\n      var lastPoint = curve.getPoint(1);\n      this.currentPoint.copy(lastPoint);\n      return this;\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(Path.prototype), \"copy\", this).call(this, source);\n\n      this.currentPoint.copy(source.currentPoint);\n      return this;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var data = _get(_getPrototypeOf(Path.prototype), \"toJSON\", this).call(this);\n\n      data.currentPoint = this.currentPoint.toArray();\n      return data;\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(Path.prototype), \"fromJSON\", this).call(this, json);\n\n      this.currentPoint.fromArray(json.currentPoint);\n      return this;\n    }\n  }]);\n\n  return Path;\n}(CurvePath);\n\nexport { Path };","map":null,"metadata":{},"sourceType":"module"}