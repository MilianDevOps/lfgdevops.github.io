{"ast":null,"code":"import C from \"react\";\n\nvar V = e => {\n  let r = g(e);\n  return C.createElement(C.Fragment, null, r);\n};\n\nimport { useRef as L, isValidElement as $, cloneElement as ee } from \"react\";\nimport { useState as K, useRef as v, useCallback as S } from \"react\";\nimport { useEffect as W, useLayoutEffect as X } from \"react\";\n\nvar B = Object.defineProperty,\n    G = Object.defineProperties,\n    H = Object.getOwnPropertyDescriptors,\n    O = Object.getOwnPropertySymbols,\n    J = Object.prototype.hasOwnProperty,\n    N = Object.prototype.propertyIsEnumerable,\n    w = (e, r, t) => r in e ? B(e, r, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : e[r] = t,\n    A = (e, r) => {\n  for (var t in r || (r = {})) J.call(r, t) && w(e, t, r[t]);\n\n  if (O) for (var t of O(r)) N.call(r, t) && w(e, t, r[t]);\n  return e;\n},\n    P = (e, r) => G(e, H(r)),\n    F = typeof window == \"undefined\" ? W : X,\n    j = _ref => {\n  let {\n    isPlaying: e,\n    duration: r,\n    startAt: t = 0,\n    updateInterval: n = 0,\n    onComplete: s,\n    onUpdate: c\n  } = _ref;\n  let [o, p] = K(t),\n      f = v(t * -1e3),\n      m = v(null),\n      a = v(null),\n      b = v(null),\n      u = v({\n    elapsedTimeRef: 0,\n    startAtRef: t,\n    durationRef: r,\n    updateIntervalRef: n\n  });\n  u.current = P(A({}, u.current), {\n    durationRef: r,\n    updateIntervalRef: n\n  });\n\n  let l = d => {\n    let i = d / 1e3;\n\n    if (a.current === null) {\n      a.current = i, m.current = requestAnimationFrame(l);\n      return;\n    }\n\n    let {\n      durationRef: R,\n      elapsedTimeRef: _,\n      updateIntervalRef: T,\n      startAtRef: E\n    } = u.current,\n        z = i - a.current,\n        h = _ + z;\n    a.current = i, u.current = P(A({}, u.current), {\n      elapsedTimeRef: h\n    });\n    let Q = E + (T === 0 ? h : (h / T | 0) * T),\n        U = E + h,\n        I = typeof R == \"number\" && U >= R;\n    p(I ? R : Q), I || (m.current = requestAnimationFrame(l));\n  },\n      y = () => {\n    m.current && cancelAnimationFrame(m.current), b.current && clearTimeout(b.current), a.current = null;\n  },\n      x = S(d => {\n    let i = typeof d == \"number\" ? d : t;\n    y(), u.current = P(A({}, u.current), {\n      elapsedTimeRef: 0,\n      startAtRef: i\n    }), p(i), e && (m.current = requestAnimationFrame(l));\n  }, [e, t]);\n\n  return F(() => {\n    if (c == null || c(o), r && o >= r) {\n      f.current += r * 1e3;\n      let {\n        shouldRepeat: d = !1,\n        delay: i = 0,\n        newStartAt: R\n      } = (s == null ? void 0 : s(f.current / 1e3)) || {};\n      d && (b.current = setTimeout(() => x(R), i * 1e3));\n    }\n  }, [o, r]), F(() => (e && (m.current = requestAnimationFrame(l)), y), [e]), {\n    elapsedTime: o,\n    reset: x\n  };\n};\n\nvar q = {\n  easeOutQuad: (e, r, t, n) => (e /= n, -t * e * (e - 2) + r),\n  easeInQuad: (e, r, t, n) => (e /= n, t * e * e + r),\n  random: (e, r, t) => Math.floor(Math.random() * (t - r + 1) + r),\n  linear: (e, r, t, n) => t * e / n + r\n},\n    M = (e, r) => {\n  let t = e.filter(n => !(r == null ? void 0 : r.includes(n))).length;\n  return 1 / (t - 1);\n};\n\nvar Y = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"],\n    k = function () {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Y;\n  return e[Math.floor(Math.random() * e.length)];\n},\n    Z = (e, r) => {\n  if (r === 0) return [e, 0];\n  let t = r > 1 ? 1 : r;\n  t = t < 0 ? 0 : t;\n  let n = e * t;\n  return [e - n, n];\n},\n    D = _ref2 => {\n  let {\n    characters: e,\n    duration: r,\n    revealDuration: t = .6,\n    revealEasing: n = \"linear\",\n    ignoreCharacterSet: s\n  } = _ref2;\n\n  let c = Array.isArray(e) ? e : e.split(\"\"),\n      [o, p] = Z(r, t),\n      f = q[n],\n      m = M(c, s),\n      a = 0,\n      b = u => {\n    if (u || t === 0) return r;\n    let l = f(a * m, 0, p, 1);\n    return a += 1, o + l;\n  };\n\n  return c.map(u => {\n    let l = !!(s == null ? void 0 : s.find(y => y === u));\n    return {\n      character: u,\n      isIgnored: l,\n      revealTime: b(l)\n    };\n  });\n};\n\nvar g = e => {\n  var c;\n  let r = L(),\n      t = L([]),\n      {\n    elapsedTime: n\n  } = j({\n    isPlaying: e.isPlaying,\n    duration: e.duration,\n    updateInterval: (c = e.updateInterval) != null ? c : .065,\n    onComplete: e.onComplete\n  });\n  if (r.current === n) return t.current;\n  r.current = n, t.current = [];\n  let s = D(e);\n\n  for (let o = 0; o < s.length; o++) {\n    let {\n      character: p,\n      isIgnored: f,\n      revealTime: m\n    } = s[o],\n        a = f || n >= m ? p : k(e.characterSet);\n    t.current.push($(a) ? ee(a, {\n      key: o\n    }) : a);\n  }\n\n  return t.current;\n};\n\nexport { V as RandomReveal, g as useRandomReveal };","map":null,"metadata":{},"sourceType":"module"}