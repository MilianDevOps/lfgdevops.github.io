{"ast":null,"code":"import _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nvar TorusGeometry = /*#__PURE__*/function (_BufferGeometry) {\n  _inherits(TorusGeometry, _BufferGeometry);\n\n  var _super = _createSuper(TorusGeometry);\n\n  function TorusGeometry() {\n    var _this;\n\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var tube = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.4;\n    var radialSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;\n    var tubularSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6;\n    var arc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI * 2;\n\n    _classCallCheck(this, TorusGeometry);\n\n    _this = _super.call(this);\n    _this.type = 'TorusGeometry';\n    _this.parameters = {\n      radius: radius,\n      tube: tube,\n      radialSegments: radialSegments,\n      tubularSegments: tubularSegments,\n      arc: arc\n    };\n    radialSegments = Math.floor(radialSegments);\n    tubularSegments = Math.floor(tubularSegments); // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helper variables\n\n    var center = new Vector3();\n    var vertex = new Vector3();\n    var normal = new Vector3(); // generate vertices, normals and uvs\n\n    for (var j = 0; j <= radialSegments; j++) {\n      for (var i = 0; i <= tubularSegments; i++) {\n        var u = i / tubularSegments * arc;\n        var v = j / radialSegments * Math.PI * 2; // vertex\n\n        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);\n        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);\n        vertex.z = tube * Math.sin(v);\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n        center.x = radius * Math.cos(u);\n        center.y = radius * Math.sin(u);\n        normal.subVectors(vertex, center).normalize();\n        normals.push(normal.x, normal.y, normal.z); // uv\n\n        uvs.push(i / tubularSegments);\n        uvs.push(j / radialSegments);\n      }\n    } // generate indices\n\n\n    for (var _j = 1; _j <= radialSegments; _j++) {\n      for (var _i = 1; _i <= tubularSegments; _i++) {\n        // indices\n        var a = (tubularSegments + 1) * _j + _i - 1;\n        var b = (tubularSegments + 1) * (_j - 1) + _i - 1;\n        var c = (tubularSegments + 1) * (_j - 1) + _i;\n        var d = (tubularSegments + 1) * _j + _i; // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    _this.setIndex(indices);\n\n    _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\n    _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\n    _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    return _this;\n  }\n\n  _createClass(TorusGeometry, null, [{\n    key: \"fromJSON\",\n    value: function fromJSON(data) {\n      return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);\n    }\n  }]);\n\n  return TorusGeometry;\n}(BufferGeometry);\n\nexport { TorusGeometry, TorusGeometry as TorusBufferGeometry };","map":null,"metadata":{},"sourceType":"module"}