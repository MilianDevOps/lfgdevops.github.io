{"ast":null,"code":"import { Vector3 } from './Vector3.js';\nimport { Sphere } from './Sphere.js';\nimport { Plane } from './Plane.js';\n\nconst _sphere = /*@__PURE__*/new Sphere();\n\nconst _vector = /*@__PURE__*/new Vector3();\n\nclass Frustum {\n  constructor() {\n    let p0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Plane();\n    let p1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Plane();\n    let p2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Plane();\n    let p3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Plane();\n    let p4 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Plane();\n    let p5 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Plane();\n    this.planes = [p0, p1, p2, p3, p4, p5];\n  }\n\n  set(p0, p1, p2, p3, p4, p5) {\n    const planes = this.planes;\n    planes[0].copy(p0);\n    planes[1].copy(p1);\n    planes[2].copy(p2);\n    planes[3].copy(p3);\n    planes[4].copy(p4);\n    planes[5].copy(p5);\n    return this;\n  }\n\n  copy(frustum) {\n    const planes = this.planes;\n\n    for (let i = 0; i < 6; i++) {\n      planes[i].copy(frustum.planes[i]);\n    }\n\n    return this;\n  }\n\n  setFromProjectionMatrix(m) {\n    const planes = this.planes;\n    const me = m.elements;\n    const me0 = me[0],\n          me1 = me[1],\n          me2 = me[2],\n          me3 = me[3];\n    const me4 = me[4],\n          me5 = me[5],\n          me6 = me[6],\n          me7 = me[7];\n    const me8 = me[8],\n          me9 = me[9],\n          me10 = me[10],\n          me11 = me[11];\n    const me12 = me[12],\n          me13 = me[13],\n          me14 = me[14],\n          me15 = me[15];\n    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\n    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\n    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\n    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\n    return this;\n  }\n\n  intersectsObject(object) {\n    const geometry = object.geometry;\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);\n\n    return this.intersectsSphere(_sphere);\n  }\n\n  intersectsSprite(sprite) {\n    _sphere.center.set(0, 0, 0);\n\n    _sphere.radius = 0.7071067811865476;\n\n    _sphere.applyMatrix4(sprite.matrixWorld);\n\n    return this.intersectsSphere(_sphere);\n  }\n\n  intersectsSphere(sphere) {\n    const planes = this.planes;\n    const center = sphere.center;\n    const negRadius = -sphere.radius;\n\n    for (let i = 0; i < 6; i++) {\n      const distance = planes[i].distanceToPoint(center);\n\n      if (distance < negRadius) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  intersectsBox(box) {\n    const planes = this.planes;\n\n    for (let i = 0; i < 6; i++) {\n      const plane = planes[i]; // corner at max distance\n\n      _vector.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n      _vector.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n      _vector.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n      if (plane.distanceToPoint(_vector) < 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  containsPoint(point) {\n    const planes = this.planes;\n\n    for (let i = 0; i < 6; i++) {\n      if (planes[i].distanceToPoint(point) < 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n}\n\nexport { Frustum };","map":null,"metadata":{},"sourceType":"module"}