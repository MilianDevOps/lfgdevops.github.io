{"ast":null,"code":"import { Color } from '../../math/Color.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { UniformsLib } from '../shaders/UniformsLib.js';\n\nfunction UniformsCache() {\n  var lights = {};\n  return {\n    get: function get(light) {\n      if (lights[light.id] !== undefined) {\n        return lights[light.id];\n      }\n\n      var uniforms;\n\n      switch (light.type) {\n        case 'DirectionalLight':\n          uniforms = {\n            direction: new Vector3(),\n            color: new Color()\n          };\n          break;\n\n        case 'SpotLight':\n          uniforms = {\n            position: new Vector3(),\n            direction: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            coneCos: 0,\n            penumbraCos: 0,\n            decay: 0\n          };\n          break;\n\n        case 'PointLight':\n          uniforms = {\n            position: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            decay: 0\n          };\n          break;\n\n        case 'HemisphereLight':\n          uniforms = {\n            direction: new Vector3(),\n            skyColor: new Color(),\n            groundColor: new Color()\n          };\n          break;\n\n        case 'RectAreaLight':\n          uniforms = {\n            color: new Color(),\n            position: new Vector3(),\n            halfWidth: new Vector3(),\n            halfHeight: new Vector3()\n          };\n          break;\n      }\n\n      lights[light.id] = uniforms;\n      return uniforms;\n    }\n  };\n}\n\nfunction ShadowUniformsCache() {\n  var lights = {};\n  return {\n    get: function get(light) {\n      if (lights[light.id] !== undefined) {\n        return lights[light.id];\n      }\n\n      var uniforms;\n\n      switch (light.type) {\n        case 'DirectionalLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n\n        case 'SpotLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n\n        case 'PointLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2(),\n            shadowCameraNear: 1,\n            shadowCameraFar: 1000\n          };\n          break;\n        // TODO (abelnation): set RectAreaLight shadow uniforms\n      }\n\n      lights[light.id] = uniforms;\n      return uniforms;\n    }\n  };\n}\n\nvar nextVersion = 0;\n\nfunction shadowCastingLightsFirst(lightA, lightB) {\n  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);\n}\n\nfunction WebGLLights(extensions, capabilities) {\n  var cache = new UniformsCache();\n  var shadowCache = ShadowUniformsCache();\n  var state = {\n    version: 0,\n    hash: {\n      directionalLength: -1,\n      pointLength: -1,\n      spotLength: -1,\n      rectAreaLength: -1,\n      hemiLength: -1,\n      numDirectionalShadows: -1,\n      numPointShadows: -1,\n      numSpotShadows: -1\n    },\n    ambient: [0, 0, 0],\n    probe: [],\n    directional: [],\n    directionalShadow: [],\n    directionalShadowMap: [],\n    directionalShadowMatrix: [],\n    spot: [],\n    spotShadow: [],\n    spotShadowMap: [],\n    spotShadowMatrix: [],\n    rectArea: [],\n    rectAreaLTC1: null,\n    rectAreaLTC2: null,\n    point: [],\n    pointShadow: [],\n    pointShadowMap: [],\n    pointShadowMatrix: [],\n    hemi: []\n  };\n\n  for (var i = 0; i < 9; i++) {\n    state.probe.push(new Vector3());\n  }\n\n  var vector3 = new Vector3();\n  var matrix4 = new Matrix4();\n  var matrix42 = new Matrix4();\n\n  function setup(lights, physicallyCorrectLights) {\n    var r = 0,\n        g = 0,\n        b = 0;\n\n    for (var _i = 0; _i < 9; _i++) {\n      state.probe[_i].set(0, 0, 0);\n    }\n\n    var directionalLength = 0;\n    var pointLength = 0;\n    var spotLength = 0;\n    var rectAreaLength = 0;\n    var hemiLength = 0;\n    var numDirectionalShadows = 0;\n    var numPointShadows = 0;\n    var numSpotShadows = 0;\n    lights.sort(shadowCastingLightsFirst); // artist-friendly light intensity scaling factor\n\n    var scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;\n\n    for (var _i2 = 0, l = lights.length; _i2 < l; _i2++) {\n      var light = lights[_i2];\n      var color = light.color;\n      var intensity = light.intensity;\n      var distance = light.distance;\n      var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;\n\n      if (light.isAmbientLight) {\n        r += color.r * intensity * scaleFactor;\n        g += color.g * intensity * scaleFactor;\n        b += color.b * intensity * scaleFactor;\n      } else if (light.isLightProbe) {\n        for (var j = 0; j < 9; j++) {\n          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);\n        }\n      } else if (light.isDirectionalLight) {\n        var uniforms = cache.get(light);\n        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);\n\n        if (light.castShadow) {\n          var shadow = light.shadow;\n          var shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          state.directionalShadow[directionalLength] = shadowUniforms;\n          state.directionalShadowMap[directionalLength] = shadowMap;\n          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;\n          numDirectionalShadows++;\n        }\n\n        state.directional[directionalLength] = uniforms;\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        var _uniforms = cache.get(light);\n\n        _uniforms.position.setFromMatrixPosition(light.matrixWorld);\n\n        _uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);\n\n        _uniforms.distance = distance;\n        _uniforms.coneCos = Math.cos(light.angle);\n        _uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));\n        _uniforms.decay = light.decay;\n\n        if (light.castShadow) {\n          var _shadow = light.shadow;\n\n          var _shadowUniforms = shadowCache.get(light);\n\n          _shadowUniforms.shadowBias = _shadow.bias;\n          _shadowUniforms.shadowNormalBias = _shadow.normalBias;\n          _shadowUniforms.shadowRadius = _shadow.radius;\n          _shadowUniforms.shadowMapSize = _shadow.mapSize;\n          state.spotShadow[spotLength] = _shadowUniforms;\n          state.spotShadowMap[spotLength] = shadowMap;\n          state.spotShadowMatrix[spotLength] = light.shadow.matrix;\n          numSpotShadows++;\n        }\n\n        state.spot[spotLength] = _uniforms;\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        var _uniforms2 = cache.get(light); // (a) intensity is the total visible light emitted\n        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n        // (b) intensity is the brightness of the light\n\n\n        _uniforms2.color.copy(color).multiplyScalar(intensity);\n\n        _uniforms2.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n\n        _uniforms2.halfHeight.set(0.0, light.height * 0.5, 0.0);\n\n        state.rectArea[rectAreaLength] = _uniforms2;\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        var _uniforms3 = cache.get(light);\n\n        _uniforms3.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);\n\n        _uniforms3.distance = light.distance;\n        _uniforms3.decay = light.decay;\n\n        if (light.castShadow) {\n          var _shadow2 = light.shadow;\n\n          var _shadowUniforms2 = shadowCache.get(light);\n\n          _shadowUniforms2.shadowBias = _shadow2.bias;\n          _shadowUniforms2.shadowNormalBias = _shadow2.normalBias;\n          _shadowUniforms2.shadowRadius = _shadow2.radius;\n          _shadowUniforms2.shadowMapSize = _shadow2.mapSize;\n          _shadowUniforms2.shadowCameraNear = _shadow2.camera.near;\n          _shadowUniforms2.shadowCameraFar = _shadow2.camera.far;\n          state.pointShadow[pointLength] = _shadowUniforms2;\n          state.pointShadowMap[pointLength] = shadowMap;\n          state.pointShadowMatrix[pointLength] = light.shadow.matrix;\n          numPointShadows++;\n        }\n\n        state.point[pointLength] = _uniforms3;\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        var _uniforms4 = cache.get(light);\n\n        _uniforms4.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);\n\n        _uniforms4.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);\n\n        state.hemi[hemiLength] = _uniforms4;\n        hemiLength++;\n      }\n    }\n\n    if (rectAreaLength > 0) {\n      if (capabilities.isWebGL2) {\n        // WebGL 2\n        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n      } else {\n        // WebGL 1\n        if (extensions.has('OES_texture_float_linear') === true) {\n          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n        } else if (extensions.has('OES_texture_half_float_linear') === true) {\n          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n        } else {\n          console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');\n        }\n      }\n    }\n\n    state.ambient[0] = r;\n    state.ambient[1] = g;\n    state.ambient[2] = b;\n    var hash = state.hash;\n\n    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {\n      state.directional.length = directionalLength;\n      state.spot.length = spotLength;\n      state.rectArea.length = rectAreaLength;\n      state.point.length = pointLength;\n      state.hemi.length = hemiLength;\n      state.directionalShadow.length = numDirectionalShadows;\n      state.directionalShadowMap.length = numDirectionalShadows;\n      state.pointShadow.length = numPointShadows;\n      state.pointShadowMap.length = numPointShadows;\n      state.spotShadow.length = numSpotShadows;\n      state.spotShadowMap.length = numSpotShadows;\n      state.directionalShadowMatrix.length = numDirectionalShadows;\n      state.pointShadowMatrix.length = numPointShadows;\n      state.spotShadowMatrix.length = numSpotShadows;\n      hash.directionalLength = directionalLength;\n      hash.pointLength = pointLength;\n      hash.spotLength = spotLength;\n      hash.rectAreaLength = rectAreaLength;\n      hash.hemiLength = hemiLength;\n      hash.numDirectionalShadows = numDirectionalShadows;\n      hash.numPointShadows = numPointShadows;\n      hash.numSpotShadows = numSpotShadows;\n      state.version = nextVersion++;\n    }\n  }\n\n  function setupView(lights, camera) {\n    var directionalLength = 0;\n    var pointLength = 0;\n    var spotLength = 0;\n    var rectAreaLength = 0;\n    var hemiLength = 0;\n    var viewMatrix = camera.matrixWorldInverse;\n\n    for (var _i3 = 0, l = lights.length; _i3 < l; _i3++) {\n      var light = lights[_i3];\n\n      if (light.isDirectionalLight) {\n        var uniforms = state.directional[directionalLength];\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms.direction.sub(vector3);\n        uniforms.direction.transformDirection(viewMatrix);\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        var _uniforms5 = state.spot[spotLength];\n\n        _uniforms5.position.setFromMatrixPosition(light.matrixWorld);\n\n        _uniforms5.position.applyMatrix4(viewMatrix);\n\n        _uniforms5.direction.setFromMatrixPosition(light.matrixWorld);\n\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n\n        _uniforms5.direction.sub(vector3);\n\n        _uniforms5.direction.transformDirection(viewMatrix);\n\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        var _uniforms6 = state.rectArea[rectAreaLength];\n\n        _uniforms6.position.setFromMatrixPosition(light.matrixWorld);\n\n        _uniforms6.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors\n\n\n        matrix42.identity();\n        matrix4.copy(light.matrixWorld);\n        matrix4.premultiply(viewMatrix);\n        matrix42.extractRotation(matrix4);\n\n        _uniforms6.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n\n        _uniforms6.halfHeight.set(0.0, light.height * 0.5, 0.0);\n\n        _uniforms6.halfWidth.applyMatrix4(matrix42);\n\n        _uniforms6.halfHeight.applyMatrix4(matrix42);\n\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        var _uniforms7 = state.point[pointLength];\n\n        _uniforms7.position.setFromMatrixPosition(light.matrixWorld);\n\n        _uniforms7.position.applyMatrix4(viewMatrix);\n\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        var _uniforms8 = state.hemi[hemiLength];\n\n        _uniforms8.direction.setFromMatrixPosition(light.matrixWorld);\n\n        _uniforms8.direction.transformDirection(viewMatrix);\n\n        _uniforms8.direction.normalize();\n\n        hemiLength++;\n      }\n    }\n  }\n\n  return {\n    setup: setup,\n    setupView: setupView,\n    state: state\n  };\n}\n\nexport { WebGLLights };","map":null,"metadata":{},"sourceType":"module"}