{"ast":null,"code":"import _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as MathUtils from './MathUtils.js';\n\nvar Quaternion = /*#__PURE__*/function () {\n  function Quaternion() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    _classCallCheck(this, Quaternion);\n\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n  }\n\n  _createClass(Quaternion, [{\n    key: \"x\",\n    get: function get() {\n      return this._x;\n    },\n    set: function set(value) {\n      this._x = value;\n\n      this._onChangeCallback();\n    }\n  }, {\n    key: \"y\",\n    get: function get() {\n      return this._y;\n    },\n    set: function set(value) {\n      this._y = value;\n\n      this._onChangeCallback();\n    }\n  }, {\n    key: \"z\",\n    get: function get() {\n      return this._z;\n    },\n    set: function set(value) {\n      this._z = value;\n\n      this._onChangeCallback();\n    }\n  }, {\n    key: \"w\",\n    get: function get() {\n      return this._w;\n    },\n    set: function set(value) {\n      this._w = value;\n\n      this._onChangeCallback();\n    }\n  }, {\n    key: \"set\",\n    value: function set(x, y, z, w) {\n      this._x = x;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(this._x, this._y, this._z, this._w);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(quaternion) {\n      this._x = quaternion.x;\n      this._y = quaternion.y;\n      this._z = quaternion.z;\n      this._w = quaternion.w;\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: \"setFromEuler\",\n    value: function setFromEuler(euler, update) {\n      if (!(euler && euler.isEuler)) {\n        throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');\n      }\n\n      var x = euler._x,\n          y = euler._y,\n          z = euler._z,\n          order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/\n      // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n      //\tcontent/SpinCalc.m\n\n      var cos = Math.cos;\n      var sin = Math.sin;\n      var c1 = cos(x / 2);\n      var c2 = cos(y / 2);\n      var c3 = cos(z / 2);\n      var s1 = sin(x / 2);\n      var s2 = sin(y / 2);\n      var s3 = sin(z / 2);\n\n      switch (order) {\n        case 'XYZ':\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n\n        case 'YXZ':\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n\n        case 'ZXY':\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n\n        case 'ZYX':\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n\n        case 'YZX':\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n\n        case 'XZY':\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n\n        default:\n          console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);\n      }\n\n      if (update !== false) this._onChangeCallback();\n      return this;\n    }\n  }, {\n    key: \"setFromAxisAngle\",\n    value: function setFromAxisAngle(axis, angle) {\n      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n      // assumes axis is normalized\n      var halfAngle = angle / 2,\n          s = Math.sin(halfAngle);\n      this._x = axis.x * s;\n      this._y = axis.y * s;\n      this._z = axis.z * s;\n      this._w = Math.cos(halfAngle);\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: \"setFromRotationMatrix\",\n    value: function setFromRotationMatrix(m) {\n      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n      var te = m.elements,\n          m11 = te[0],\n          m12 = te[4],\n          m13 = te[8],\n          m21 = te[1],\n          m22 = te[5],\n          m23 = te[9],\n          m31 = te[2],\n          m32 = te[6],\n          m33 = te[10],\n          trace = m11 + m22 + m33;\n\n      if (trace > 0) {\n        var s = 0.5 / Math.sqrt(trace + 1.0);\n        this._w = 0.25 / s;\n        this._x = (m32 - m23) * s;\n        this._y = (m13 - m31) * s;\n        this._z = (m21 - m12) * s;\n      } else if (m11 > m22 && m11 > m33) {\n        var _s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n        this._w = (m32 - m23) / _s;\n        this._x = 0.25 * _s;\n        this._y = (m12 + m21) / _s;\n        this._z = (m13 + m31) / _s;\n      } else if (m22 > m33) {\n        var _s2 = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n        this._w = (m13 - m31) / _s2;\n        this._x = (m12 + m21) / _s2;\n        this._y = 0.25 * _s2;\n        this._z = (m23 + m32) / _s2;\n      } else {\n        var _s3 = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n        this._w = (m21 - m12) / _s3;\n        this._x = (m13 + m31) / _s3;\n        this._y = (m23 + m32) / _s3;\n        this._z = 0.25 * _s3;\n      }\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: \"setFromUnitVectors\",\n    value: function setFromUnitVectors(vFrom, vTo) {\n      // assumes direction vectors vFrom and vTo are normalized\n      var r = vFrom.dot(vTo) + 1;\n\n      if (r < Number.EPSILON) {\n        // vFrom and vTo point in opposite directions\n        r = 0;\n\n        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n          this._x = -vFrom.y;\n          this._y = vFrom.x;\n          this._z = 0;\n          this._w = r;\n        } else {\n          this._x = 0;\n          this._y = -vFrom.z;\n          this._z = vFrom.y;\n          this._w = r;\n        }\n      } else {\n        // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n        this._w = r;\n      }\n\n      return this.normalize();\n    }\n  }, {\n    key: \"angleTo\",\n    value: function angleTo(q) {\n      return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));\n    }\n  }, {\n    key: \"rotateTowards\",\n    value: function rotateTowards(q, step) {\n      var angle = this.angleTo(q);\n      if (angle === 0) return this;\n      var t = Math.min(1, step / angle);\n      this.slerp(q, t);\n      return this;\n    }\n  }, {\n    key: \"identity\",\n    value: function identity() {\n      return this.set(0, 0, 0, 1);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      // quaternion is assumed to have unit length\n      return this.conjugate();\n    }\n  }, {\n    key: \"conjugate\",\n    value: function conjugate() {\n      this._x *= -1;\n      this._y *= -1;\n      this._z *= -1;\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: \"dot\",\n    value: function dot(v) {\n      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n    }\n  }, {\n    key: \"lengthSq\",\n    value: function lengthSq() {\n      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var l = this.length();\n\n      if (l === 0) {\n        this._x = 0;\n        this._y = 0;\n        this._z = 0;\n        this._w = 1;\n      } else {\n        l = 1 / l;\n        this._x = this._x * l;\n        this._y = this._y * l;\n        this._z = this._z * l;\n        this._w = this._w * l;\n      }\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(q, p) {\n      if (p !== undefined) {\n        console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');\n        return this.multiplyQuaternions(q, p);\n      }\n\n      return this.multiplyQuaternions(this, q);\n    }\n  }, {\n    key: \"premultiply\",\n    value: function premultiply(q) {\n      return this.multiplyQuaternions(q, this);\n    }\n  }, {\n    key: \"multiplyQuaternions\",\n    value: function multiplyQuaternions(a, b) {\n      // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n      var qax = a._x,\n          qay = a._y,\n          qaz = a._z,\n          qaw = a._w;\n      var qbx = b._x,\n          qby = b._y,\n          qbz = b._z,\n          qbw = b._w;\n      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: \"slerp\",\n    value: function slerp(qb, t) {\n      if (t === 0) return this;\n      if (t === 1) return this.copy(qb);\n      var x = this._x,\n          y = this._y,\n          z = this._z,\n          w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n      var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n      if (cosHalfTheta < 0) {\n        this._w = -qb._w;\n        this._x = -qb._x;\n        this._y = -qb._y;\n        this._z = -qb._z;\n        cosHalfTheta = -cosHalfTheta;\n      } else {\n        this.copy(qb);\n      }\n\n      if (cosHalfTheta >= 1.0) {\n        this._w = w;\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        return this;\n      }\n\n      var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n      if (sqrSinHalfTheta <= Number.EPSILON) {\n        var s = 1 - t;\n        this._w = s * w + t * this._w;\n        this._x = s * x + t * this._x;\n        this._y = s * y + t * this._y;\n        this._z = s * z + t * this._z;\n        this.normalize();\n\n        this._onChangeCallback();\n\n        return this;\n      }\n\n      var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n      var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n      var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\n          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n      this._w = w * ratioA + this._w * ratioB;\n      this._x = x * ratioA + this._x * ratioB;\n      this._y = y * ratioA + this._y * ratioB;\n      this._z = z * ratioA + this._z * ratioB;\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: \"slerpQuaternions\",\n    value: function slerpQuaternions(qa, qb, t) {\n      return this.copy(qa).slerp(qb, t);\n    }\n  }, {\n    key: \"random\",\n    value: function random() {\n      // Derived from http://planning.cs.uiuc.edu/node198.html\n      // Note, this source uses w, x, y, z ordering,\n      // so we swap the order below.\n      var u1 = Math.random();\n      var sqrt1u1 = Math.sqrt(1 - u1);\n      var sqrtu1 = Math.sqrt(u1);\n      var u2 = 2 * Math.PI * Math.random();\n      var u3 = 2 * Math.PI * Math.random();\n      return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(quaternion) {\n      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n    }\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this._x = array[offset];\n      this._y = array[offset + 1];\n      this._z = array[offset + 2];\n      this._w = array[offset + 3];\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._w;\n      return array;\n    }\n  }, {\n    key: \"fromBufferAttribute\",\n    value: function fromBufferAttribute(attribute, index) {\n      this._x = attribute.getX(index);\n      this._y = attribute.getY(index);\n      this._z = attribute.getZ(index);\n      this._w = attribute.getW(index);\n      return this;\n    }\n  }, {\n    key: \"_onChange\",\n    value: function _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n  }, {\n    key: \"_onChangeCallback\",\n    value: function _onChangeCallback() {}\n  }], [{\n    key: \"slerp\",\n    value: function slerp(qa, qb, qm, t) {\n      console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');\n      return qm.slerpQuaternions(qa, qb, t);\n    }\n  }, {\n    key: \"slerpFlat\",\n    value: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n      // fuzz-free, array-based Quaternion SLERP operation\n      var x0 = src0[srcOffset0 + 0],\n          y0 = src0[srcOffset0 + 1],\n          z0 = src0[srcOffset0 + 2],\n          w0 = src0[srcOffset0 + 3];\n      var x1 = src1[srcOffset1 + 0],\n          y1 = src1[srcOffset1 + 1],\n          z1 = src1[srcOffset1 + 2],\n          w1 = src1[srcOffset1 + 3];\n\n      if (t === 0) {\n        dst[dstOffset + 0] = x0;\n        dst[dstOffset + 1] = y0;\n        dst[dstOffset + 2] = z0;\n        dst[dstOffset + 3] = w0;\n        return;\n      }\n\n      if (t === 1) {\n        dst[dstOffset + 0] = x1;\n        dst[dstOffset + 1] = y1;\n        dst[dstOffset + 2] = z1;\n        dst[dstOffset + 3] = w1;\n        return;\n      }\n\n      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n        var s = 1 - t;\n        var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n            dir = cos >= 0 ? 1 : -1,\n            sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:\n\n        if (sqrSin > Number.EPSILON) {\n          var sin = Math.sqrt(sqrSin),\n              len = Math.atan2(sin, cos * dir);\n          s = Math.sin(s * len) / sin;\n          t = Math.sin(t * len) / sin;\n        }\n\n        var tDir = t * dir;\n        x0 = x0 * s + x1 * tDir;\n        y0 = y0 * s + y1 * tDir;\n        z0 = z0 * s + z1 * tDir;\n        w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:\n\n        if (s === 1 - t) {\n          var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n          x0 *= f;\n          y0 *= f;\n          z0 *= f;\n          w0 *= f;\n        }\n      }\n\n      dst[dstOffset] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n    }\n  }, {\n    key: \"multiplyQuaternionsFlat\",\n    value: function multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n      var x0 = src0[srcOffset0];\n      var y0 = src0[srcOffset0 + 1];\n      var z0 = src0[srcOffset0 + 2];\n      var w0 = src0[srcOffset0 + 3];\n      var x1 = src1[srcOffset1];\n      var y1 = src1[srcOffset1 + 1];\n      var z1 = src1[srcOffset1 + 2];\n      var w1 = src1[srcOffset1 + 3];\n      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n      return dst;\n    }\n  }]);\n\n  return Quaternion;\n}();\n\nQuaternion.prototype.isQuaternion = true;\nexport { Quaternion };","map":null,"metadata":{},"sourceType":"module"}