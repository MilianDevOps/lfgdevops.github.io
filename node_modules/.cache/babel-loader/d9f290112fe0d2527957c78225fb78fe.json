{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Group } from '../../objects/Group.js';\nvar _moveEvent = {\n  type: 'move'\n};\n\nvar WebXRController = /*#__PURE__*/function () {\n  function WebXRController() {\n    _classCallCheck(this, WebXRController);\n\n    this._targetRay = null;\n    this._grip = null;\n    this._hand = null;\n  }\n\n  _createClass(WebXRController, [{\n    key: \"getHandSpace\",\n    value: function getHandSpace() {\n      if (this._hand === null) {\n        this._hand = new Group();\n        this._hand.matrixAutoUpdate = false;\n        this._hand.visible = false;\n        this._hand.joints = {};\n        this._hand.inputState = {\n          pinching: false\n        };\n      }\n\n      return this._hand;\n    }\n  }, {\n    key: \"getTargetRaySpace\",\n    value: function getTargetRaySpace() {\n      if (this._targetRay === null) {\n        this._targetRay = new Group();\n        this._targetRay.matrixAutoUpdate = false;\n        this._targetRay.visible = false;\n        this._targetRay.hasLinearVelocity = false;\n        this._targetRay.linearVelocity = new Vector3();\n        this._targetRay.hasAngularVelocity = false;\n        this._targetRay.angularVelocity = new Vector3();\n      }\n\n      return this._targetRay;\n    }\n  }, {\n    key: \"getGripSpace\",\n    value: function getGripSpace() {\n      if (this._grip === null) {\n        this._grip = new Group();\n        this._grip.matrixAutoUpdate = false;\n        this._grip.visible = false;\n        this._grip.hasLinearVelocity = false;\n        this._grip.linearVelocity = new Vector3();\n        this._grip.hasAngularVelocity = false;\n        this._grip.angularVelocity = new Vector3();\n      }\n\n      return this._grip;\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      if (this._targetRay !== null) {\n        this._targetRay.dispatchEvent(event);\n      }\n\n      if (this._grip !== null) {\n        this._grip.dispatchEvent(event);\n      }\n\n      if (this._hand !== null) {\n        this._hand.dispatchEvent(event);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(inputSource) {\n      this.dispatchEvent({\n        type: 'disconnected',\n        data: inputSource\n      });\n\n      if (this._targetRay !== null) {\n        this._targetRay.visible = false;\n      }\n\n      if (this._grip !== null) {\n        this._grip.visible = false;\n      }\n\n      if (this._hand !== null) {\n        this._hand.visible = false;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"update\",\n    value: function update(inputSource, frame, referenceSpace) {\n      var inputPose = null;\n      var gripPose = null;\n      var handPose = null;\n      var targetRay = this._targetRay;\n      var grip = this._grip;\n      var hand = this._hand;\n\n      if (inputSource && frame.session.visibilityState !== 'visible-blurred') {\n        if (targetRay !== null) {\n          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);\n\n          if (inputPose !== null) {\n            targetRay.matrix.fromArray(inputPose.transform.matrix);\n            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);\n\n            if (inputPose.linearVelocity) {\n              targetRay.hasLinearVelocity = true;\n              targetRay.linearVelocity.copy(inputPose.linearVelocity);\n            } else {\n              targetRay.hasLinearVelocity = false;\n            }\n\n            if (inputPose.angularVelocity) {\n              targetRay.hasAngularVelocity = true;\n              targetRay.angularVelocity.copy(inputPose.angularVelocity);\n            } else {\n              targetRay.hasAngularVelocity = false;\n            }\n\n            this.dispatchEvent(_moveEvent);\n          }\n        }\n\n        if (hand && inputSource.hand) {\n          handPose = true;\n\n          var _iterator = _createForOfIteratorHelper(inputSource.hand.values()),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var inputjoint = _step.value;\n              // Update the joints groups with the XRJoint poses\n              var jointPose = frame.getJointPose(inputjoint, referenceSpace);\n\n              if (hand.joints[inputjoint.jointName] === undefined) {\n                // The transform of this joint will be updated with the joint pose on each frame\n                var _joint = new Group();\n\n                _joint.matrixAutoUpdate = false;\n                _joint.visible = false;\n                hand.joints[inputjoint.jointName] = _joint; // ??\n\n                hand.add(_joint);\n              }\n\n              var joint = hand.joints[inputjoint.jointName];\n\n              if (jointPose !== null) {\n                joint.matrix.fromArray(jointPose.transform.matrix);\n                joint.matrix.decompose(joint.position, joint.rotation, joint.scale);\n                joint.jointRadius = jointPose.radius;\n              }\n\n              joint.visible = jointPose !== null;\n            } // Custom events\n            // Check pinchz\n\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          var indexTip = hand.joints['index-finger-tip'];\n          var thumbTip = hand.joints['thumb-tip'];\n          var distance = indexTip.position.distanceTo(thumbTip.position);\n          var distanceToPinch = 0.02;\n          var threshold = 0.005;\n\n          if (hand.inputState.pinching && distance > distanceToPinch + threshold) {\n            hand.inputState.pinching = false;\n            this.dispatchEvent({\n              type: 'pinchend',\n              handedness: inputSource.handedness,\n              target: this\n            });\n          } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {\n            hand.inputState.pinching = true;\n            this.dispatchEvent({\n              type: 'pinchstart',\n              handedness: inputSource.handedness,\n              target: this\n            });\n          }\n        } else {\n          if (grip !== null && inputSource.gripSpace) {\n            gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);\n\n            if (gripPose !== null) {\n              grip.matrix.fromArray(gripPose.transform.matrix);\n              grip.matrix.decompose(grip.position, grip.rotation, grip.scale);\n\n              if (gripPose.linearVelocity) {\n                grip.hasLinearVelocity = true;\n                grip.linearVelocity.copy(gripPose.linearVelocity);\n              } else {\n                grip.hasLinearVelocity = false;\n              }\n\n              if (gripPose.angularVelocity) {\n                grip.hasAngularVelocity = true;\n                grip.angularVelocity.copy(gripPose.angularVelocity);\n              } else {\n                grip.hasAngularVelocity = false;\n              }\n            }\n          }\n        }\n      }\n\n      if (targetRay !== null) {\n        targetRay.visible = inputPose !== null;\n      }\n\n      if (grip !== null) {\n        grip.visible = gripPose !== null;\n      }\n\n      if (hand !== null) {\n        hand.visible = handPose !== null;\n      }\n\n      return this;\n    }\n  }]);\n\n  return WebXRController;\n}();\n\nexport { WebXRController };","map":null,"metadata":{},"sourceType":"module"}