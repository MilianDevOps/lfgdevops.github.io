{"ast":null,"code":"import _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nvar WireframeGeometry = /*#__PURE__*/function (_BufferGeometry) {\n  _inherits(WireframeGeometry, _BufferGeometry);\n\n  var _super = _createSuper(WireframeGeometry);\n\n  function WireframeGeometry() {\n    var _this;\n\n    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, WireframeGeometry);\n\n    _this = _super.call(this);\n    _this.type = 'WireframeGeometry';\n    _this.parameters = {\n      geometry: geometry\n    };\n\n    if (geometry !== null) {\n      // buffer\n      var vertices = [];\n      var edges = new Set(); // helper variables\n\n      var start = new Vector3();\n      var end = new Vector3();\n\n      if (geometry.index !== null) {\n        // indexed BufferGeometry\n        var position = geometry.attributes.position;\n        var indices = geometry.index;\n        var groups = geometry.groups;\n\n        if (groups.length === 0) {\n          groups = [{\n            start: 0,\n            count: indices.count,\n            materialIndex: 0\n          }];\n        } // create a data structure that contains all eges without duplicates\n\n\n        for (var o = 0, ol = groups.length; o < ol; ++o) {\n          var group = groups[o];\n          var groupStart = group.start;\n          var groupCount = group.count;\n\n          for (var i = groupStart, l = groupStart + groupCount; i < l; i += 3) {\n            for (var j = 0; j < 3; j++) {\n              var index1 = indices.getX(i + j);\n              var index2 = indices.getX(i + (j + 1) % 3);\n              start.fromBufferAttribute(position, index1);\n              end.fromBufferAttribute(position, index2);\n\n              if (isUniqueEdge(start, end, edges) === true) {\n                vertices.push(start.x, start.y, start.z);\n                vertices.push(end.x, end.y, end.z);\n              }\n            }\n          }\n        }\n      } else {\n        // non-indexed BufferGeometry\n        var _position = geometry.attributes.position;\n\n        for (var _i = 0, _l = _position.count / 3; _i < _l; _i++) {\n          for (var _j = 0; _j < 3; _j++) {\n            // three edges per triangle, an edge is represented as (index1, index2)\n            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n            var _index = 3 * _i + _j;\n\n            var _index2 = 3 * _i + (_j + 1) % 3;\n\n            start.fromBufferAttribute(_position, _index);\n            end.fromBufferAttribute(_position, _index2);\n\n            if (isUniqueEdge(start, end, edges) === true) {\n              vertices.push(start.x, start.y, start.z);\n              vertices.push(end.x, end.y, end.z);\n            }\n          }\n        }\n      } // build geometry\n\n\n      _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    }\n\n    return _this;\n  }\n\n  return _createClass(WireframeGeometry);\n}(BufferGeometry);\n\nfunction isUniqueEdge(start, end, edges) {\n  var hash1 = \"\".concat(start.x, \",\").concat(start.y, \",\").concat(start.z, \"-\").concat(end.x, \",\").concat(end.y, \",\").concat(end.z);\n  var hash2 = \"\".concat(end.x, \",\").concat(end.y, \",\").concat(end.z, \"-\").concat(start.x, \",\").concat(start.y, \",\").concat(start.z); // coincident edge\n\n  if (edges.has(hash1) === true || edges.has(hash2) === true) {\n    return false;\n  } else {\n    edges.add(hash1, hash2);\n    return true;\n  }\n}\n\nexport { WireframeGeometry };","map":null,"metadata":{},"sourceType":"module"}