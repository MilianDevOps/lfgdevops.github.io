{"ast":null,"code":"import { EventDispatcher } from '../core/EventDispatcher.js';\nimport { FrontSide, FlatShading, NormalBlending, LessEqualDepth, AddEquation, OneMinusSrcAlphaFactor, SrcAlphaFactor, AlwaysStencilFunc, KeepStencilOp } from '../constants.js';\nimport * as MathUtils from '../math/MathUtils.js';\nlet materialId = 0;\n\nclass Material extends EventDispatcher {\n  constructor() {\n    super();\n    Object.defineProperty(this, 'id', {\n      value: materialId++\n    });\n    this.uuid = MathUtils.generateUUID();\n    this.name = '';\n    this.type = 'Material';\n    this.fog = true;\n    this.blending = NormalBlending;\n    this.side = FrontSide;\n    this.vertexColors = false;\n    this.opacity = 1;\n    this.transparent = false;\n    this.blendSrc = SrcAlphaFactor;\n    this.blendDst = OneMinusSrcAlphaFactor;\n    this.blendEquation = AddEquation;\n    this.blendSrcAlpha = null;\n    this.blendDstAlpha = null;\n    this.blendEquationAlpha = null;\n    this.depthFunc = LessEqualDepth;\n    this.depthTest = true;\n    this.depthWrite = true;\n    this.stencilWriteMask = 0xff;\n    this.stencilFunc = AlwaysStencilFunc;\n    this.stencilRef = 0;\n    this.stencilFuncMask = 0xff;\n    this.stencilFail = KeepStencilOp;\n    this.stencilZFail = KeepStencilOp;\n    this.stencilZPass = KeepStencilOp;\n    this.stencilWrite = false;\n    this.clippingPlanes = null;\n    this.clipIntersection = false;\n    this.clipShadows = false;\n    this.shadowSide = null;\n    this.colorWrite = true;\n    this.precision = null; // override the renderer's default precision for this material\n\n    this.polygonOffset = false;\n    this.polygonOffsetFactor = 0;\n    this.polygonOffsetUnits = 0;\n    this.dithering = false;\n    this.alphaToCoverage = false;\n    this.premultipliedAlpha = false;\n    this.visible = true;\n    this.toneMapped = true;\n    this.userData = {};\n    this.version = 0;\n    this._alphaTest = 0;\n  }\n\n  get alphaTest() {\n    return this._alphaTest;\n  }\n\n  set alphaTest(value) {\n    if (this._alphaTest > 0 !== value > 0) {\n      this.version++;\n    }\n\n    this._alphaTest = value;\n  }\n\n  onBuild() {}\n\n  onBeforeRender() {}\n\n  onBeforeCompile() {}\n\n  customProgramCacheKey() {\n    return this.onBeforeCompile.toString();\n  }\n\n  setValues(values) {\n    if (values === undefined) return;\n\n    for (const key in values) {\n      const newValue = values[key];\n\n      if (newValue === undefined) {\n        console.warn('THREE.Material: \\'' + key + '\\' parameter is undefined.');\n        continue;\n      } // for backward compatability if shading is set in the constructor\n\n\n      if (key === 'shading') {\n        console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\n        this.flatShading = newValue === FlatShading ? true : false;\n        continue;\n      }\n\n      const currentValue = this[key];\n\n      if (currentValue === undefined) {\n        console.warn('THREE.' + this.type + ': \\'' + key + '\\' is not a property of this material.');\n        continue;\n      }\n\n      if (currentValue && currentValue.isColor) {\n        currentValue.set(newValue);\n      } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {\n        currentValue.copy(newValue);\n      } else {\n        this[key] = newValue;\n      }\n    }\n  }\n\n  toJSON(meta) {\n    const isRoot = meta === undefined || typeof meta === 'string';\n\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {}\n      };\n    }\n\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Material',\n        generator: 'Material.toJSON'\n      }\n    }; // standard Material serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (this.color && this.color.isColor) data.color = this.color.getHex();\n    if (this.roughness !== undefined) data.roughness = this.roughness;\n    if (this.metalness !== undefined) data.metalness = this.metalness;\n    if (this.sheen !== undefined) data.sheen = this.sheen;\n    if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();\n    if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;\n    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();\n    if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;\n    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();\n    if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;\n    if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();\n    if (this.shininess !== undefined) data.shininess = this.shininess;\n    if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;\n    if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;\n\n    if (this.clearcoatMap && this.clearcoatMap.isTexture) {\n      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n    }\n\n    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n    }\n\n    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n    }\n\n    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;\n    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n\n    if (this.lightMap && this.lightMap.isTexture) {\n      data.lightMap = this.lightMap.toJSON(meta).uuid;\n      data.lightMapIntensity = this.lightMapIntensity;\n    }\n\n    if (this.aoMap && this.aoMap.isTexture) {\n      data.aoMap = this.aoMap.toJSON(meta).uuid;\n      data.aoMapIntensity = this.aoMapIntensity;\n    }\n\n    if (this.bumpMap && this.bumpMap.isTexture) {\n      data.bumpMap = this.bumpMap.toJSON(meta).uuid;\n      data.bumpScale = this.bumpScale;\n    }\n\n    if (this.normalMap && this.normalMap.isTexture) {\n      data.normalMap = this.normalMap.toJSON(meta).uuid;\n      data.normalMapType = this.normalMapType;\n      data.normalScale = this.normalScale.toArray();\n    }\n\n    if (this.displacementMap && this.displacementMap.isTexture) {\n      data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n      data.displacementScale = this.displacementScale;\n      data.displacementBias = this.displacementBias;\n    }\n\n    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n    if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;\n    if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;\n\n    if (this.envMap && this.envMap.isTexture) {\n      data.envMap = this.envMap.toJSON(meta).uuid;\n      if (this.combine !== undefined) data.combine = this.combine;\n    }\n\n    if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;\n    if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;\n    if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;\n\n    if (this.gradientMap && this.gradientMap.isTexture) {\n      data.gradientMap = this.gradientMap.toJSON(meta).uuid;\n    }\n\n    if (this.transmission !== undefined) data.transmission = this.transmission;\n    if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n    if (this.thickness !== undefined) data.thickness = this.thickness;\n    if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n    if (this.attenuationDistance !== undefined) data.attenuationDistance = this.attenuationDistance;\n    if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();\n    if (this.size !== undefined) data.size = this.size;\n    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n    if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;\n    if (this.blending !== NormalBlending) data.blending = this.blending;\n    if (this.side !== FrontSide) data.side = this.side;\n    if (this.vertexColors) data.vertexColors = true;\n    if (this.opacity < 1) data.opacity = this.opacity;\n    if (this.transparent === true) data.transparent = this.transparent;\n    data.depthFunc = this.depthFunc;\n    data.depthTest = this.depthTest;\n    data.depthWrite = this.depthWrite;\n    data.colorWrite = this.colorWrite;\n    data.stencilWrite = this.stencilWrite;\n    data.stencilWriteMask = this.stencilWriteMask;\n    data.stencilFunc = this.stencilFunc;\n    data.stencilRef = this.stencilRef;\n    data.stencilFuncMask = this.stencilFuncMask;\n    data.stencilFail = this.stencilFail;\n    data.stencilZFail = this.stencilZFail;\n    data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)\n\n    if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;\n    if (this.polygonOffset === true) data.polygonOffset = true;\n    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;\n    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;\n    if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;\n    if (this.dashSize !== undefined) data.dashSize = this.dashSize;\n    if (this.gapSize !== undefined) data.gapSize = this.gapSize;\n    if (this.scale !== undefined) data.scale = this.scale;\n    if (this.dithering === true) data.dithering = true;\n    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n    if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;\n    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;\n    if (this.wireframe === true) data.wireframe = this.wireframe;\n    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n    if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;\n    if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;\n    if (this.flatShading === true) data.flatShading = this.flatShading;\n    if (this.visible === false) data.visible = false;\n    if (this.toneMapped === false) data.toneMapped = false;\n    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON\n\n    function extractFromCache(cache) {\n      const values = [];\n\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n    }\n\n    return data;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.name = source.name;\n    this.fog = source.fog;\n    this.blending = source.blending;\n    this.side = source.side;\n    this.vertexColors = source.vertexColors;\n    this.opacity = source.opacity;\n    this.transparent = source.transparent;\n    this.blendSrc = source.blendSrc;\n    this.blendDst = source.blendDst;\n    this.blendEquation = source.blendEquation;\n    this.blendSrcAlpha = source.blendSrcAlpha;\n    this.blendDstAlpha = source.blendDstAlpha;\n    this.blendEquationAlpha = source.blendEquationAlpha;\n    this.depthFunc = source.depthFunc;\n    this.depthTest = source.depthTest;\n    this.depthWrite = source.depthWrite;\n    this.stencilWriteMask = source.stencilWriteMask;\n    this.stencilFunc = source.stencilFunc;\n    this.stencilRef = source.stencilRef;\n    this.stencilFuncMask = source.stencilFuncMask;\n    this.stencilFail = source.stencilFail;\n    this.stencilZFail = source.stencilZFail;\n    this.stencilZPass = source.stencilZPass;\n    this.stencilWrite = source.stencilWrite;\n    const srcPlanes = source.clippingPlanes;\n    let dstPlanes = null;\n\n    if (srcPlanes !== null) {\n      const n = srcPlanes.length;\n      dstPlanes = new Array(n);\n\n      for (let i = 0; i !== n; ++i) {\n        dstPlanes[i] = srcPlanes[i].clone();\n      }\n    }\n\n    this.clippingPlanes = dstPlanes;\n    this.clipIntersection = source.clipIntersection;\n    this.clipShadows = source.clipShadows;\n    this.shadowSide = source.shadowSide;\n    this.colorWrite = source.colorWrite;\n    this.precision = source.precision;\n    this.polygonOffset = source.polygonOffset;\n    this.polygonOffsetFactor = source.polygonOffsetFactor;\n    this.polygonOffsetUnits = source.polygonOffsetUnits;\n    this.dithering = source.dithering;\n    this.alphaTest = source.alphaTest;\n    this.alphaToCoverage = source.alphaToCoverage;\n    this.premultipliedAlpha = source.premultipliedAlpha;\n    this.visible = source.visible;\n    this.toneMapped = source.toneMapped;\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n    return this;\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n\n}\n\nMaterial.prototype.isMaterial = true;\nexport { Material };","map":null,"metadata":{},"sourceType":"module"}