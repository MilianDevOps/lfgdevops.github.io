{"ast":null,"code":"import _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nvar SphereGeometry = /*#__PURE__*/function (_BufferGeometry) {\n  _inherits(SphereGeometry, _BufferGeometry);\n\n  var _super = _createSuper(SphereGeometry);\n\n  function SphereGeometry() {\n    var _this;\n\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var widthSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n    var heightSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16;\n    var phiStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var phiLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI * 2;\n    var thetaStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var thetaLength = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Math.PI;\n\n    _classCallCheck(this, SphereGeometry);\n\n    _this = _super.call(this);\n    _this.type = 'SphereGeometry';\n    _this.parameters = {\n      radius: radius,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      phiStart: phiStart,\n      phiLength: phiLength,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    var index = 0;\n    var grid = [];\n    var vertex = new Vector3();\n    var normal = new Vector3(); // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // generate vertices, normals and uvs\n\n    for (var iy = 0; iy <= heightSegments; iy++) {\n      var verticesRow = [];\n      var v = iy / heightSegments; // special case for the poles\n\n      var uOffset = 0;\n\n      if (iy == 0 && thetaStart == 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy == heightSegments && thetaEnd == Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n\n      for (var ix = 0; ix <= widthSegments; ix++) {\n        var u = ix / widthSegments; // vertex\n\n        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n        normal.copy(vertex).normalize();\n        normals.push(normal.x, normal.y, normal.z); // uv\n\n        uvs.push(u + uOffset, 1 - v);\n        verticesRow.push(index++);\n      }\n\n      grid.push(verticesRow);\n    } // indices\n\n\n    for (var _iy = 0; _iy < heightSegments; _iy++) {\n      for (var _ix = 0; _ix < widthSegments; _ix++) {\n        var a = grid[_iy][_ix + 1];\n        var b = grid[_iy][_ix];\n        var c = grid[_iy + 1][_ix];\n        var d = grid[_iy + 1][_ix + 1];\n        if (_iy !== 0 || thetaStart > 0) indices.push(a, b, d);\n        if (_iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    _this.setIndex(indices);\n\n    _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\n    _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\n    _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    return _this;\n  }\n\n  _createClass(SphereGeometry, null, [{\n    key: \"fromJSON\",\n    value: function fromJSON(data) {\n      return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);\n    }\n  }]);\n\n  return SphereGeometry;\n}(BufferGeometry);\n\nexport { SphereGeometry, SphereGeometry as SphereBufferGeometry };","map":null,"metadata":{},"sourceType":"module"}