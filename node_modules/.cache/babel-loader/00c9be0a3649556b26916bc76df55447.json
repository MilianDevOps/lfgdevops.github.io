{"ast":null,"code":"import { Vector3 } from '../math/Vector3.js';\nimport { BufferAttribute } from './BufferAttribute.js';\n\nconst _vector = /*@__PURE__*/new Vector3();\n\nclass InterleavedBufferAttribute {\n  constructor(interleavedBuffer, itemSize, offset) {\n    let normalized = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    this.name = '';\n    this.data = interleavedBuffer;\n    this.itemSize = itemSize;\n    this.offset = offset;\n    this.normalized = normalized === true;\n  }\n\n  get count() {\n    return this.data.count;\n  }\n\n  get array() {\n    return this.data.array;\n  }\n\n  set needsUpdate(value) {\n    this.data.needsUpdate = value;\n  }\n\n  applyMatrix4(m) {\n    for (let i = 0, l = this.data.count; i < l; i++) {\n      _vector.x = this.getX(i);\n      _vector.y = this.getY(i);\n      _vector.z = this.getZ(i);\n\n      _vector.applyMatrix4(m);\n\n      this.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n\n    return this;\n  }\n\n  applyNormalMatrix(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector.x = this.getX(i);\n      _vector.y = this.getY(i);\n      _vector.z = this.getZ(i);\n\n      _vector.applyNormalMatrix(m);\n\n      this.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n\n    return this;\n  }\n\n  transformDirection(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector.x = this.getX(i);\n      _vector.y = this.getY(i);\n      _vector.z = this.getZ(i);\n\n      _vector.transformDirection(m);\n\n      this.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n\n    return this;\n  }\n\n  setX(index, x) {\n    this.data.array[index * this.data.stride + this.offset] = x;\n    return this;\n  }\n\n  setY(index, y) {\n    this.data.array[index * this.data.stride + this.offset + 1] = y;\n    return this;\n  }\n\n  setZ(index, z) {\n    this.data.array[index * this.data.stride + this.offset + 2] = z;\n    return this;\n  }\n\n  setW(index, w) {\n    this.data.array[index * this.data.stride + this.offset + 3] = w;\n    return this;\n  }\n\n  getX(index) {\n    return this.data.array[index * this.data.stride + this.offset];\n  }\n\n  getY(index) {\n    return this.data.array[index * this.data.stride + this.offset + 1];\n  }\n\n  getZ(index) {\n    return this.data.array[index * this.data.stride + this.offset + 2];\n  }\n\n  getW(index) {\n    return this.data.array[index * this.data.stride + this.offset + 3];\n  }\n\n  setXY(index, x, y) {\n    index = index * this.data.stride + this.offset;\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    return this;\n  }\n\n  setXYZ(index, x, y, z) {\n    index = index * this.data.stride + this.offset;\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n    return this;\n  }\n\n  setXYZW(index, x, y, z, w) {\n    index = index * this.data.stride + this.offset;\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n    this.data.array[index + 3] = w;\n    return this;\n  }\n\n  clone(data) {\n    if (data === undefined) {\n      console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');\n      const array = [];\n\n      for (let i = 0; i < this.count; i++) {\n        const index = i * this.data.stride + this.offset;\n\n        for (let j = 0; j < this.itemSize; j++) {\n          array.push(this.data.array[index + j]);\n        }\n      }\n\n      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);\n    } else {\n      if (data.interleavedBuffers === undefined) {\n        data.interleavedBuffers = {};\n      }\n\n      if (data.interleavedBuffers[this.data.uuid] === undefined) {\n        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);\n      }\n\n      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);\n    }\n  }\n\n  toJSON(data) {\n    if (data === undefined) {\n      console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');\n      const array = [];\n\n      for (let i = 0; i < this.count; i++) {\n        const index = i * this.data.stride + this.offset;\n\n        for (let j = 0; j < this.itemSize; j++) {\n          array.push(this.data.array[index + j]);\n        }\n      } // deinterleave data and save it as an ordinary buffer attribute for now\n\n\n      return {\n        itemSize: this.itemSize,\n        type: this.array.constructor.name,\n        array: array,\n        normalized: this.normalized\n      };\n    } else {\n      // save as true interlaved attribtue\n      if (data.interleavedBuffers === undefined) {\n        data.interleavedBuffers = {};\n      }\n\n      if (data.interleavedBuffers[this.data.uuid] === undefined) {\n        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);\n      }\n\n      return {\n        isInterleavedBufferAttribute: true,\n        itemSize: this.itemSize,\n        data: this.data.uuid,\n        offset: this.offset,\n        normalized: this.normalized\n      };\n    }\n  }\n\n}\n\nInterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;\nexport { InterleavedBufferAttribute };","map":null,"metadata":{},"sourceType":"module"}