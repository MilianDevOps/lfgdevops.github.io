{"ast":null,"code":"import _objectSpread from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport { raycast as _raycast, raycastFirst as _raycastFirst, shapecast as _shapecast, intersectsGeometry as _intersectsGeometry, setBuffer, clearBuffer } from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\nimport { convertRaycastIntersect } from '../utils/GeometryRayIntersectUtilities.js';\nvar SKIP_GENERATION = Symbol('skip tree generation');\nvar aabb = /* @__PURE__ */new Box3();\nvar aabb2 = /* @__PURE__ */new Box3();\nvar tempMatrix = /* @__PURE__ */new Matrix4();\nvar obb = /* @__PURE__ */new OrientedBox();\nvar obb2 = /* @__PURE__ */new OrientedBox();\nvar temp = /* @__PURE__ */new Vector3();\nvar temp1 = /* @__PURE__ */new Vector3();\nvar temp2 = /* @__PURE__ */new Vector3();\nvar temp3 = /* @__PURE__ */new Vector3();\nvar temp4 = /* @__PURE__ */new Vector3();\nvar tempBox = /* @__PURE__ */new Box3();\nvar trianglePool = /* @__PURE__ */new PrimitivePool(function () {\n  return new ExtendedTriangle();\n});\nexport var MeshBVH = /*#__PURE__*/function () {\n  function MeshBVH(geometry) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, MeshBVH);\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    } // default options\n\n\n    options = Object.assign(_defineProperty({\n      strategy: CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      useSharedArrayBuffer: false,\n      setBoundingBox: true,\n      onProgress: null\n    }, SKIP_GENERATION, false), options);\n\n    if (options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined') {\n      throw new Error('MeshBVH: SharedArrayBuffer is not available.');\n    }\n\n    this._roots = null;\n\n    if (!options[SKIP_GENERATION]) {\n      this._roots = buildPackedTree(geometry, options);\n\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    } // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n\n\n    this.geometry = geometry;\n  }\n\n  _createClass(MeshBVH, [{\n    key: \"refit\",\n    value: function refit() {\n      var nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (nodeIndices && Array.isArray(nodeIndices)) {\n        nodeIndices = new Set(nodeIndices);\n      }\n\n      var geometry = this.geometry;\n      var indexArr = geometry.index.array;\n      var posAttr = geometry.attributes.position;\n      var posArr = posAttr.array; // support for an interleaved position buffer\n\n      var bufferOffset = posAttr.offset || 0;\n      var stride = 3;\n\n      if (posAttr.isInterleavedBufferAttribute) {\n        stride = posAttr.data.stride;\n      }\n\n      var buffer, uint32Array, uint16Array, float32Array;\n      var byteOffset = 0;\n      var roots = this._roots;\n\n      for (var i = 0, l = roots.length; i < l; i++) {\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n\n        _traverse(0, byteOffset);\n\n        byteOffset += buffer.byteLength;\n      }\n\n      function _traverse(node32Index, byteOffset) {\n        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          var minx = Infinity;\n          var miny = Infinity;\n          var minz = Infinity;\n          var maxx = -Infinity;\n          var maxy = -Infinity;\n          var maxz = -Infinity;\n\n          for (var _i = 3 * offset, _l = 3 * (offset + count); _i < _l; _i++) {\n            var index = indexArr[_i] * stride + bufferOffset;\n            var x = posArr[index + 0];\n            var y = posArr[index + 1];\n            var z = posArr[index + 2];\n            if (x < minx) minx = x;\n            if (x > maxx) maxx = x;\n            if (y < miny) miny = y;\n            if (y > maxy) maxy = y;\n            if (z < minz) minz = z;\n            if (z > maxz) maxz = z;\n          }\n\n          if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n            float32Array[node32Index + 0] = minx;\n            float32Array[node32Index + 1] = miny;\n            float32Array[node32Index + 2] = minz;\n            float32Array[node32Index + 3] = maxx;\n            float32Array[node32Index + 4] = maxy;\n            float32Array[node32Index + 5] = maxz;\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          var left = node32Index + 8;\n          var right = uint32Array[node32Index + 6]; // the identifying node indices provided by the shapecast function include offsets of all\n          // root buffers to guarantee they're unique between roots so offset left and right indices here.\n\n          var offsetLeft = left + byteOffset;\n          var offsetRight = right + byteOffset;\n          var forceChildren = force;\n          var includesLeft = false;\n          var includesRight = false;\n\n          if (nodeIndices) {\n            // if we see that neither the left or right child are included in the set that need to be updated\n            // then we assume that all children need to be updated.\n            if (!forceChildren) {\n              includesLeft = nodeIndices.has(offsetLeft);\n              includesRight = nodeIndices.has(offsetRight);\n              forceChildren = !includesLeft && !includesRight;\n            }\n          } else {\n            includesLeft = true;\n            includesRight = true;\n          }\n\n          var traverseLeft = forceChildren || includesLeft;\n          var traverseRight = forceChildren || includesRight;\n          var leftChange = false;\n\n          if (traverseLeft) {\n            leftChange = _traverse(left, byteOffset, forceChildren);\n          }\n\n          var rightChange = false;\n\n          if (traverseRight) {\n            rightChange = _traverse(right, byteOffset, forceChildren);\n          }\n\n          var didChange = leftChange || rightChange;\n\n          if (didChange) {\n            for (var _i2 = 0; _i2 < 3; _i2++) {\n              var lefti = left + _i2;\n              var righti = right + _i2;\n              var minLeftValue = float32Array[lefti];\n              var maxLeftValue = float32Array[lefti + 3];\n              var minRightValue = float32Array[righti];\n              var maxRightValue = float32Array[righti + 3];\n              float32Array[node32Index + _i2] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n              float32Array[node32Index + _i2 + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n            }\n          }\n\n          return didChange;\n        }\n      }\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(callback) {\n      var rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var buffer = this._roots[rootIndex];\n      var uint32Array = new Uint32Array(buffer);\n      var uint16Array = new Uint16Array(buffer);\n\n      _traverse(0);\n\n      function _traverse(node32Index) {\n        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n        } else {\n          // TODO: use node functions here\n          var left = node32Index + BYTES_PER_NODE / 4;\n          var right = uint32Array[node32Index + 6];\n          var splitAxis = uint32Array[node32Index + 7];\n          var stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n\n          if (!stopTraversal) {\n            _traverse(left, depth + 1);\n\n            _traverse(right, depth + 1);\n          }\n        }\n      }\n    }\n    /* Core Cast Functions */\n\n  }, {\n    key: \"raycast\",\n    value: function raycast(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var intersects = [];\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        var startCount = intersects.length;\n        setBuffer(roots[i]);\n\n        _raycast(0, geometry, materialSide, ray, intersects);\n\n        clearBuffer();\n\n        if (isArrayMaterial) {\n          var materialIndex = groups[i].materialIndex;\n\n          for (var j = startCount, jl = intersects.length; j < jl; j++) {\n            intersects[j].face.materialIndex = materialIndex;\n          }\n        }\n      }\n\n      return intersects;\n    }\n  }, {\n    key: \"raycastFirst\",\n    value: function raycastFirst(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var closestResult = null;\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        setBuffer(roots[i]);\n\n        var result = _raycastFirst(0, geometry, materialSide, ray);\n\n        clearBuffer();\n\n        if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n          closestResult = result;\n\n          if (isArrayMaterial) {\n            result.face.materialIndex = groups[i].materialIndex;\n          }\n        }\n      }\n\n      return closestResult;\n    }\n  }, {\n    key: \"intersectsGeometry\",\n    value: function intersectsGeometry(otherGeometry, geomToMesh) {\n      var geometry = this.geometry;\n      var result = false;\n\n      var _iterator = _createForOfIteratorHelper(this._roots),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var root = _step.value;\n          setBuffer(root);\n          result = _intersectsGeometry(0, geometry, otherGeometry, geomToMesh);\n          clearBuffer();\n\n          if (result) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"shapecast\",\n    value: function shapecast(callbacks, _intersectsTriangleFunc, _orderNodesFunc) {\n      var geometry = this.geometry;\n\n      if (callbacks instanceof Function) {\n        if (_intersectsTriangleFunc) {\n          // Support the previous function signature that provided three sequential index buffer\n          // indices here.\n          var originalTriangleFunc = _intersectsTriangleFunc;\n\n          _intersectsTriangleFunc = function _intersectsTriangleFunc(tri, index, contained, depth) {\n            var i3 = index * 3;\n            return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);\n          };\n        }\n\n        callbacks = {\n          boundsTraverseOrder: _orderNodesFunc,\n          intersectsBounds: callbacks,\n          intersectsTriangle: _intersectsTriangleFunc,\n          intersectsRange: null\n        };\n        console.warn('MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.');\n      }\n\n      var triangle = trianglePool.getPrimitive();\n      var _callbacks = callbacks,\n          boundsTraverseOrder = _callbacks.boundsTraverseOrder,\n          intersectsBounds = _callbacks.intersectsBounds,\n          intersectsRange = _callbacks.intersectsRange,\n          intersectsTriangle = _callbacks.intersectsTriangle;\n\n      if (intersectsRange && intersectsTriangle) {\n        var originalIntersectsRange = intersectsRange;\n\n        intersectsRange = function intersectsRange(offset, count, contained, depth, nodeIndex) {\n          if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n            return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          }\n\n          return true;\n        };\n      } else if (!intersectsRange) {\n        if (intersectsTriangle) {\n          intersectsRange = function intersectsRange(offset, count, contained, depth) {\n            return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          };\n        } else {\n          intersectsRange = function intersectsRange(offset, count, contained) {\n            return contained;\n          };\n        }\n      }\n\n      var result = false;\n      var byteOffset = 0;\n\n      var _iterator2 = _createForOfIteratorHelper(this._roots),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var root = _step2.value;\n          setBuffer(root);\n          result = _shapecast(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n          clearBuffer();\n\n          if (result) {\n            break;\n          }\n\n          byteOffset += root.byteLength;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      trianglePool.releasePrimitive(triangle);\n      return result;\n    }\n  }, {\n    key: \"bvhcast\",\n    value: function bvhcast(otherBvh, matrixToLocal, callbacks) {\n      // BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n      // than an approach that walks down the tree (see bvhcast.js file for more info).\n      var intersectsRanges = callbacks.intersectsRanges,\n          intersectsTriangles = callbacks.intersectsTriangles;\n      var indexAttr = this.geometry.index;\n      var positionAttr = this.geometry.attributes.position;\n      var otherIndexAttr = otherBvh.geometry.index;\n      var otherPositionAttr = otherBvh.geometry.attributes.position;\n      tempMatrix.copy(matrixToLocal).invert();\n      var triangle = trianglePool.getPrimitive();\n      var triangle2 = trianglePool.getPrimitive();\n\n      if (intersectsTriangles) {\n        var iterateOverDoubleTriangles = function iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n          for (var i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {\n            setTriangle(triangle2, i2 * 3, otherIndexAttr, otherPositionAttr);\n            triangle2.a.applyMatrix4(matrixToLocal);\n            triangle2.b.applyMatrix4(matrixToLocal);\n            triangle2.c.applyMatrix4(matrixToLocal);\n            triangle2.needsUpdate = true;\n\n            for (var i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {\n              setTriangle(triangle, i1 * 3, indexAttr, positionAttr);\n              triangle.needsUpdate = true;\n\n              if (intersectsTriangles(triangle, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n                return true;\n              }\n            }\n          }\n\n          return false;\n        };\n\n        if (intersectsRanges) {\n          var originalIntersectsRanges = intersectsRanges;\n\n          intersectsRanges = function intersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n            if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n              return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n            }\n\n            return true;\n          };\n        } else {\n          intersectsRanges = iterateOverDoubleTriangles;\n        }\n      }\n\n      this.getBoundingBox(aabb2);\n      aabb2.applyMatrix4(matrixToLocal);\n      var result = this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return aabb2.intersectsBox(box);\n        },\n        intersectsRange: function intersectsRange(offset1, count1, contained, depth1, nodeIndex1, box) {\n          aabb.copy(box);\n          aabb.applyMatrix4(tempMatrix);\n          return otherBvh.shapecast({\n            intersectsBounds: function intersectsBounds(box) {\n              return aabb.intersectsBox(box);\n            },\n            intersectsRange: function intersectsRange(offset2, count2, contained, depth2, nodeIndex2) {\n              return intersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);\n            }\n          });\n        }\n      });\n      trianglePool.releasePrimitive(triangle);\n      trianglePool.releasePrimitive(triangle2);\n      return result;\n    }\n    /* Derived Cast Functions */\n\n  }, {\n    key: \"intersectsBox\",\n    value: function intersectsBox(box, boxToMesh) {\n      obb.set(box.min, box.max, boxToMesh);\n      obb.needsUpdate = true;\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return obb.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return obb.intersectsTriangle(tri);\n        }\n      });\n    }\n  }, {\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(sphere) {\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return sphere.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return tri.intersectsSphere(sphere);\n        }\n      });\n    }\n  }, {\n    key: \"closestPointToGeometry\",\n    value: function closestPointToGeometry(otherGeometry, geometryToBvh) {\n      var target1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var target2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var minThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var maxThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      obb.needsUpdate = true;\n      var geometry = this.geometry;\n      var pos = geometry.attributes.position;\n      var index = geometry.index;\n      var otherPos = otherGeometry.attributes.position;\n      var otherIndex = otherGeometry.index;\n      var triangle = trianglePool.getPrimitive();\n      var triangle2 = trianglePool.getPrimitive();\n      var tempTarget1 = temp1;\n      var tempTargetDest1 = temp2;\n      var tempTarget2 = null;\n      var tempTargetDest2 = null;\n\n      if (target2) {\n        tempTarget2 = temp3;\n        tempTargetDest2 = temp4;\n      }\n\n      var closestDistance = Infinity;\n      var closestDistanceTriIndex = null;\n      var closestDistanceOtherTriIndex = null;\n      tempMatrix.copy(geometryToBvh).invert();\n      obb2.matrix.copy(tempMatrix);\n      this.shapecast({\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          return obb.distanceToBox(box);\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          if (score < closestDistance && score < maxThreshold) {\n            // if we know the triangles of this bounds will be intersected next then\n            // save the bounds to use during triangle checks.\n            if (isLeaf) {\n              obb2.min.copy(box.min);\n              obb2.max.copy(box.max);\n              obb2.needsUpdate = true;\n            }\n\n            return true;\n          }\n\n          return false;\n        },\n        intersectsRange: function intersectsRange(offset, count) {\n          if (otherGeometry.boundsTree) {\n            // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n            // the closest bounds in the other geometry to check.\n            return otherGeometry.boundsTree.shapecast({\n              boundsTraverseOrder: function boundsTraverseOrder(box) {\n                return obb2.distanceToBox(box);\n              },\n              intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n                return score < closestDistance && score < maxThreshold;\n              },\n              intersectsRange: function intersectsRange(otherOffset, otherCount) {\n                for (var i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {\n                  setTriangle(triangle2, i2, otherIndex, otherPos);\n                  triangle2.a.applyMatrix4(geometryToBvh);\n                  triangle2.b.applyMatrix4(geometryToBvh);\n                  triangle2.c.applyMatrix4(geometryToBvh);\n                  triangle2.needsUpdate = true;\n\n                  for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                    setTriangle(triangle, i, index, pos);\n                    triangle.needsUpdate = true;\n                    var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n                    if (dist < closestDistance) {\n                      tempTargetDest1.copy(tempTarget1);\n\n                      if (tempTargetDest2) {\n                        tempTargetDest2.copy(tempTarget2);\n                      }\n\n                      closestDistance = dist;\n                      closestDistanceTriIndex = i / 3;\n                      closestDistanceOtherTriIndex = i2 / 3;\n                    } // stop traversal if we find a point that's under the given threshold\n\n\n                    if (dist < minThreshold) {\n                      return true;\n                    }\n                  }\n                }\n              }\n            });\n          } else {\n            // If no bounds tree then we'll just check every triangle.\n            var triCount = otherIndex ? otherIndex.count : otherPos.count;\n\n            for (var i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {\n              setTriangle(triangle2, i2, otherIndex, otherPos);\n              triangle2.a.applyMatrix4(geometryToBvh);\n              triangle2.b.applyMatrix4(geometryToBvh);\n              triangle2.c.applyMatrix4(geometryToBvh);\n              triangle2.needsUpdate = true;\n\n              for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                setTriangle(triangle, i, index, pos);\n                triangle.needsUpdate = true;\n                var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n                if (dist < closestDistance) {\n                  tempTargetDest1.copy(tempTarget1);\n\n                  if (tempTargetDest2) {\n                    tempTargetDest2.copy(tempTarget2);\n                  }\n\n                  closestDistance = dist;\n                  closestDistanceTriIndex = i / 3;\n                  closestDistanceOtherTriIndex = i2 / 3;\n                } // stop traversal if we find a point that's under the given threshold\n\n\n                if (dist < minThreshold) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      });\n      trianglePool.releasePrimitive(triangle);\n      trianglePool.releasePrimitive(triangle2);\n      if (closestDistance === Infinity) return null;\n      if (!target1.point) target1.point = tempTargetDest1.clone();else target1.point.copy(tempTargetDest1);\n      target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n\n      if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4(tempMatrix);\n        tempTargetDest1.applyMatrix4(tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n      }\n\n      return target1;\n    }\n  }, {\n    key: \"closestPointToPoint\",\n    value: function closestPointToPoint(point) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var minThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var maxThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      // early out if under minThreshold\n      // skip checking if over maxThreshold\n      // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n      // returns Infinity if no value found\n      var minThresholdSq = minThreshold * minThreshold;\n      var maxThresholdSq = maxThreshold * maxThreshold;\n      var closestDistanceSq = Infinity;\n      var closestDistanceTriIndex = null;\n      this.shapecast({\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          temp.copy(point).clamp(box.min, box.max);\n          return temp.distanceToSquared(point);\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          return score < closestDistanceSq && score < maxThresholdSq;\n        },\n        intersectsTriangle: function intersectsTriangle(tri, triIndex) {\n          tri.closestPointToPoint(point, temp);\n          var distSq = point.distanceToSquared(temp);\n\n          if (distSq < closestDistanceSq) {\n            temp1.copy(temp);\n            closestDistanceSq = distSq;\n            closestDistanceTriIndex = triIndex;\n          }\n\n          if (distSq < minThresholdSq) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n      });\n      if (closestDistanceSq === Infinity) return null;\n      var closestDistance = Math.sqrt(closestDistanceSq);\n      if (!target.point) target.point = temp1.clone();else target.point.copy(temp1);\n      target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n      return target;\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(target) {\n      target.makeEmpty();\n      var roots = this._roots;\n      roots.forEach(function (buffer) {\n        arrayToBox(0, new Float32Array(buffer), tempBox);\n        target.union(tempBox);\n      });\n      return target;\n    }\n  }], [{\n    key: \"serialize\",\n    value: function serialize(bvh) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (options.isBufferGeometry) {\n        console.warn('MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.');\n        return MeshBVH.serialize(arguments[0], {\n          cloneBuffers: arguments[2] === undefined ? true : arguments[2]\n        });\n      }\n\n      options = _objectSpread({\n        cloneBuffers: true\n      }, options);\n      var geometry = bvh.geometry;\n      var rootData = bvh._roots;\n      var indexAttribute = geometry.getIndex();\n      var result;\n\n      if (options.cloneBuffers) {\n        result = {\n          roots: rootData.map(function (root) {\n            return root.slice();\n          }),\n          index: indexAttribute.array.slice()\n        };\n      } else {\n        result = {\n          roots: rootData,\n          index: indexAttribute.array\n        };\n      }\n\n      return result;\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data, geometry) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (typeof options === 'boolean') {\n        console.warn('MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.');\n        return MeshBVH.deserialize(arguments[0], arguments[1], {\n          setIndex: arguments[2] === undefined ? true : arguments[2]\n        });\n      }\n\n      options = _objectSpread({\n        setIndex: true\n      }, options);\n      var index = data.index,\n          roots = data.roots;\n      var bvh = new MeshBVH(geometry, _objectSpread(_objectSpread({}, options), {}, _defineProperty({}, SKIP_GENERATION, true)));\n      bvh._roots = roots;\n\n      if (options.setIndex) {\n        var indexAttribute = geometry.getIndex();\n\n        if (indexAttribute === null) {\n          var newIndex = new BufferAttribute(data.index, 1, false);\n          geometry.setIndex(newIndex);\n        } else if (indexAttribute.array !== index) {\n          indexAttribute.array.set(index);\n          indexAttribute.needsUpdate = true;\n        }\n      }\n\n      return bvh;\n    }\n  }]);\n\n  return MeshBVH;\n}(); // Deprecation\n\nvar originalRaycast = MeshBVH.prototype.raycast;\n\nMeshBVH.prototype.raycast = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (args[0].isMesh) {\n    console.warn('MeshBVH: The function signature and results frame for \"raycast\" has changed. See docs for new signature.');\n    var mesh = args[0],\n        raycaster = args[1],\n        ray = args[2],\n        intersects = args[3];\n    var results = originalRaycast.call(this, ray, mesh.material);\n    results.forEach(function (hit) {\n      hit = convertRaycastIntersect(hit, mesh, raycaster);\n\n      if (hit) {\n        intersects.push(hit);\n      }\n    });\n    return intersects;\n  } else {\n    return originalRaycast.apply(this, args);\n  }\n};\n\nvar originalRaycastFirst = MeshBVH.prototype.raycastFirst;\n\nMeshBVH.prototype.raycastFirst = function () {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (args[0].isMesh) {\n    console.warn('MeshBVH: The function signature and results frame for \"raycastFirst\" has changed. See docs for new signature.');\n    var mesh = args[0],\n        raycaster = args[1],\n        ray = args[2];\n    return convertRaycastIntersect(originalRaycastFirst.call(this, ray, mesh.material), mesh, raycaster);\n  } else {\n    return originalRaycastFirst.apply(this, args);\n  }\n};\n\nvar originalClosestPointToPoint = MeshBVH.prototype.closestPointToPoint;\n\nMeshBVH.prototype.closestPointToPoint = function () {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  if (args[0].isMesh) {\n    console.warn('MeshBVH: The function signature and results frame for \"closestPointToPoint\" has changed. See docs for new signature.');\n    args.unshift();\n    var target = args[1];\n    var result = {};\n    args[1] = result;\n    originalClosestPointToPoint.apply(this, args);\n\n    if (target) {\n      target.copy(result.point);\n    }\n\n    return result.distance;\n  } else {\n    return originalClosestPointToPoint.apply(this, args);\n  }\n};\n\nvar originalClosestPointToGeometry = MeshBVH.prototype.closestPointToGeometry;\n\nMeshBVH.prototype.closestPointToGeometry = function () {\n  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    args[_key4] = arguments[_key4];\n  }\n\n  var target1 = args[2];\n  var target2 = args[3];\n\n  if (target1 && target1.isVector3 || target2 && target2.isVector3) {\n    console.warn('MeshBVH: The function signature and results frame for \"closestPointToGeometry\" has changed. See docs for new signature.');\n    var result1 = {};\n    var result2 = {};\n    var geometryToBvh = args[1];\n    args[2] = result1;\n    args[3] = result2;\n    originalClosestPointToGeometry.apply(this, args);\n\n    if (target1) {\n      target1.copy(result1.point);\n    }\n\n    if (target2) {\n      target2.copy(result2.point).applyMatrix4(geometryToBvh);\n    }\n\n    return result1.distance;\n  } else {\n    return originalClosestPointToGeometry.apply(this, args);\n  }\n};\n\nvar originalRefit = MeshBVH.prototype.refit;\n\nMeshBVH.prototype.refit = function () {\n  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    args[_key5] = arguments[_key5];\n  }\n\n  var nodeIndices = args[0];\n  var terminationIndices = args[1];\n\n  if (terminationIndices && (terminationIndices instanceof Set || Array.isArray(terminationIndices))) {\n    console.warn('MeshBVH: The function signature for \"refit\" has changed. See docs for new signature.');\n    var newNodeIndices = new Set();\n    terminationIndices.forEach(function (v) {\n      return newNodeIndices.add(v);\n    });\n\n    if (nodeIndices) {\n      nodeIndices.forEach(function (v) {\n        return newNodeIndices.add(v);\n      });\n    }\n\n    originalRefit.call(this, newNodeIndices);\n  } else {\n    originalRefit.apply(this, args);\n  }\n};\n\n['intersectsGeometry', 'shapecast', 'intersectsBox', 'intersectsSphere'].forEach(function (name) {\n  var originalFunc = MeshBVH.prototype[name];\n\n  MeshBVH.prototype[name] = function () {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    if (args[0] === null || args[0].isMesh) {\n      args.shift();\n      console.warn(\"MeshBVH: The function signature for \\\"\".concat(name, \"\\\" has changed and no longer takes Mesh. See docs for new signature.\"));\n    }\n\n    return originalFunc.apply(this, args);\n  };\n});","map":null,"metadata":{},"sourceType":"module"}