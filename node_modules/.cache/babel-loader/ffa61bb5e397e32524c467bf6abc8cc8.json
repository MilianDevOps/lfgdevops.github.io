{"ast":null,"code":"import { FloatType, RGBAFormat } from '../../constants.js';\nimport { DataTexture2DArray } from '../../textures/DataTexture2DArray.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Vector2 } from '../../math/Vector2.js';\n\nfunction numericalSort(a, b) {\n  return a[0] - b[0];\n}\n\nfunction absNumericalSort(a, b) {\n  return Math.abs(b[1]) - Math.abs(a[1]);\n}\n\nfunction denormalize(morph, attribute) {\n  let denominator = 1;\n  const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;\n  if (array instanceof Int8Array) denominator = 127;else if (array instanceof Int16Array) denominator = 32767;else if (array instanceof Int32Array) denominator = 2147483647;else console.error('THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array);\n  morph.divideScalar(denominator);\n}\n\nfunction WebGLMorphtargets(gl, capabilities, textures) {\n  const influencesList = {};\n  const morphInfluences = new Float32Array(8);\n  const morphTextures = new WeakMap();\n  const morph = new Vector3();\n  const workInfluences = [];\n\n  for (let i = 0; i < 8; i++) {\n    workInfluences[i] = [i, 0];\n  }\n\n  function update(object, geometry, material, program) {\n    const objectInfluences = object.morphTargetInfluences;\n\n    if (capabilities.isWebGL2 === true) {\n      // instead of using attributes, the WebGL 2 code path encodes morph targets\n      // into an array of data textures. Each layer represents a single morph target.\n      const numberOfMorphTargets = geometry.morphAttributes.position.length;\n      let entry = morphTextures.get(geometry);\n\n      if (entry === undefined || entry.count !== numberOfMorphTargets) {\n        if (entry !== undefined) entry.texture.dispose();\n        const hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n        const morphTargets = geometry.morphAttributes.position;\n        const morphNormals = geometry.morphAttributes.normal || [];\n        const numberOfVertices = geometry.attributes.position.count;\n        const numberOfVertexData = hasMorphNormals === true ? 2 : 1; // (v,n) vs. (v)\n\n        let width = numberOfVertices * numberOfVertexData;\n        let height = 1;\n\n        if (width > capabilities.maxTextureSize) {\n          height = Math.ceil(width / capabilities.maxTextureSize);\n          width = capabilities.maxTextureSize;\n        }\n\n        const buffer = new Float32Array(width * height * 4 * numberOfMorphTargets);\n        const texture = new DataTexture2DArray(buffer, width, height, numberOfMorphTargets);\n        texture.format = RGBAFormat; // using RGBA since RGB might be emulated (and is thus slower)\n\n        texture.type = FloatType;\n        texture.needsUpdate = true; // fill buffer\n\n        const vertexDataStride = numberOfVertexData * 4;\n\n        for (let i = 0; i < numberOfMorphTargets; i++) {\n          const morphTarget = morphTargets[i];\n          const morphNormal = morphNormals[i];\n          const offset = width * height * 4 * i;\n\n          for (let j = 0; j < morphTarget.count; j++) {\n            morph.fromBufferAttribute(morphTarget, j);\n            if (morphTarget.normalized === true) denormalize(morph, morphTarget);\n            const stride = j * vertexDataStride;\n            buffer[offset + stride + 0] = morph.x;\n            buffer[offset + stride + 1] = morph.y;\n            buffer[offset + stride + 2] = morph.z;\n            buffer[offset + stride + 3] = 0;\n\n            if (hasMorphNormals === true) {\n              morph.fromBufferAttribute(morphNormal, j);\n              if (morphNormal.normalized === true) denormalize(morph, morphNormal);\n              buffer[offset + stride + 4] = morph.x;\n              buffer[offset + stride + 5] = morph.y;\n              buffer[offset + stride + 6] = morph.z;\n              buffer[offset + stride + 7] = 0;\n            }\n          }\n        }\n\n        entry = {\n          count: numberOfMorphTargets,\n          texture: texture,\n          size: new Vector2(width, height)\n        };\n        morphTextures.set(geometry, entry);\n\n        function disposeTexture() {\n          texture.dispose();\n          morphTextures.delete(geometry);\n          geometry.removeEventListener('dispose', disposeTexture);\n        }\n\n        geometry.addEventListener('dispose', disposeTexture);\n      } //\n\n\n      let morphInfluencesSum = 0;\n\n      for (let i = 0; i < objectInfluences.length; i++) {\n        morphInfluencesSum += objectInfluences[i];\n      }\n\n      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n      program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);\n      program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);\n      program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);\n    } else {\n      // When object doesn't have morph target influences defined, we treat it as a 0-length array\n      // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n      const length = objectInfluences === undefined ? 0 : objectInfluences.length;\n      let influences = influencesList[geometry.id];\n\n      if (influences === undefined || influences.length !== length) {\n        // initialise list\n        influences = [];\n\n        for (let i = 0; i < length; i++) {\n          influences[i] = [i, 0];\n        }\n\n        influencesList[geometry.id] = influences;\n      } // Collect influences\n\n\n      for (let i = 0; i < length; i++) {\n        const influence = influences[i];\n        influence[0] = i;\n        influence[1] = objectInfluences[i];\n      }\n\n      influences.sort(absNumericalSort);\n\n      for (let i = 0; i < 8; i++) {\n        if (i < length && influences[i][1]) {\n          workInfluences[i][0] = influences[i][0];\n          workInfluences[i][1] = influences[i][1];\n        } else {\n          workInfluences[i][0] = Number.MAX_SAFE_INTEGER;\n          workInfluences[i][1] = 0;\n        }\n      }\n\n      workInfluences.sort(numericalSort);\n      const morphTargets = geometry.morphAttributes.position;\n      const morphNormals = geometry.morphAttributes.normal;\n      let morphInfluencesSum = 0;\n\n      for (let i = 0; i < 8; i++) {\n        const influence = workInfluences[i];\n        const index = influence[0];\n        const value = influence[1];\n\n        if (index !== Number.MAX_SAFE_INTEGER && value) {\n          if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {\n            geometry.setAttribute('morphTarget' + i, morphTargets[index]);\n          }\n\n          if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {\n            geometry.setAttribute('morphNormal' + i, morphNormals[index]);\n          }\n\n          morphInfluences[i] = value;\n          morphInfluencesSum += value;\n        } else {\n          if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {\n            geometry.deleteAttribute('morphTarget' + i);\n          }\n\n          if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {\n            geometry.deleteAttribute('morphNormal' + i);\n          }\n\n          morphInfluences[i] = 0;\n        }\n      } // GLSL shader uses formula baseinfluence * base + sum(target * influence)\n      // This allows us to switch between absolute morphs and relative morphs without changing shader code\n      // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\n\n      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n      program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);\n    }\n  }\n\n  return {\n    update: update\n  };\n}\n\nexport { WebGLMorphtargets };","map":null,"metadata":{},"sourceType":"module"}