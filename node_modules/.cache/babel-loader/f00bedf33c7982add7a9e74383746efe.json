{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass WireframeGeometry extends BufferGeometry {\n  constructor() {\n    let geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super();\n    this.type = 'WireframeGeometry';\n    this.parameters = {\n      geometry: geometry\n    };\n\n    if (geometry !== null) {\n      // buffer\n      const vertices = [];\n      const edges = new Set(); // helper variables\n\n      const start = new Vector3();\n      const end = new Vector3();\n\n      if (geometry.index !== null) {\n        // indexed BufferGeometry\n        const position = geometry.attributes.position;\n        const indices = geometry.index;\n        let groups = geometry.groups;\n\n        if (groups.length === 0) {\n          groups = [{\n            start: 0,\n            count: indices.count,\n            materialIndex: 0\n          }];\n        } // create a data structure that contains all eges without duplicates\n\n\n        for (let o = 0, ol = groups.length; o < ol; ++o) {\n          const group = groups[o];\n          const groupStart = group.start;\n          const groupCount = group.count;\n\n          for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {\n            for (let j = 0; j < 3; j++) {\n              const index1 = indices.getX(i + j);\n              const index2 = indices.getX(i + (j + 1) % 3);\n              start.fromBufferAttribute(position, index1);\n              end.fromBufferAttribute(position, index2);\n\n              if (isUniqueEdge(start, end, edges) === true) {\n                vertices.push(start.x, start.y, start.z);\n                vertices.push(end.x, end.y, end.z);\n              }\n            }\n          }\n        }\n      } else {\n        // non-indexed BufferGeometry\n        const position = geometry.attributes.position;\n\n        for (let i = 0, l = position.count / 3; i < l; i++) {\n          for (let j = 0; j < 3; j++) {\n            // three edges per triangle, an edge is represented as (index1, index2)\n            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n            const index1 = 3 * i + j;\n            const index2 = 3 * i + (j + 1) % 3;\n            start.fromBufferAttribute(position, index1);\n            end.fromBufferAttribute(position, index2);\n\n            if (isUniqueEdge(start, end, edges) === true) {\n              vertices.push(start.x, start.y, start.z);\n              vertices.push(end.x, end.y, end.z);\n            }\n          }\n        }\n      } // build geometry\n\n\n      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    }\n  }\n\n}\n\nfunction isUniqueEdge(start, end, edges) {\n  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;\n  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge\n\n  if (edges.has(hash1) === true || edges.has(hash2) === true) {\n    return false;\n  } else {\n    edges.add(hash1, hash2);\n    return true;\n  }\n}\n\nexport { WireframeGeometry };","map":null,"metadata":{},"sourceType":"module"}