{"ast":null,"code":"import { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\nimport { Mesh } from './Mesh.js';\nimport { Matrix4 } from '../math/Matrix4.js';\n\nconst _instanceLocalMatrix = /*@__PURE__*/new Matrix4();\n\nconst _instanceWorldMatrix = /*@__PURE__*/new Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _mesh = /*@__PURE__*/new Mesh();\n\nclass InstancedMesh extends Mesh {\n  constructor(geometry, material, count) {\n    super(geometry, material);\n    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);\n    this.instanceColor = null;\n    this.count = count;\n    this.frustumCulled = false;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.instanceMatrix.copy(source.instanceMatrix);\n    if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();\n    this.count = source.count;\n    return this;\n  }\n\n  getColorAt(index, color) {\n    color.fromArray(this.instanceColor.array, index * 3);\n  }\n\n  getMatrixAt(index, matrix) {\n    matrix.fromArray(this.instanceMatrix.array, index * 16);\n  }\n\n  raycast(raycaster, intersects) {\n    const matrixWorld = this.matrixWorld;\n    const raycastTimes = this.count;\n    _mesh.geometry = this.geometry;\n    _mesh.material = this.material;\n    if (_mesh.material === undefined) return;\n\n    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {\n      // calculate the world matrix for each instance\n      this.getMatrixAt(instanceId, _instanceLocalMatrix);\n\n      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance\n\n\n      _mesh.matrixWorld = _instanceWorldMatrix;\n\n      _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast\n\n\n      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n        const intersect = _instanceIntersects[i];\n        intersect.instanceId = instanceId;\n        intersect.object = this;\n        intersects.push(intersect);\n      }\n\n      _instanceIntersects.length = 0;\n    }\n  }\n\n  setColorAt(index, color) {\n    if (this.instanceColor === null) {\n      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);\n    }\n\n    color.toArray(this.instanceColor.array, index * 3);\n  }\n\n  setMatrixAt(index, matrix) {\n    matrix.toArray(this.instanceMatrix.array, index * 16);\n  }\n\n  updateMorphTargets() {}\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n}\n\nInstancedMesh.prototype.isInstancedMesh = true;\nexport { InstancedMesh };","map":null,"metadata":{},"sourceType":"module"}