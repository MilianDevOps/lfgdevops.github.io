{"ast":null,"code":"import { AnimationAction } from './AnimationAction.js';\nimport { EventDispatcher } from '../core/EventDispatcher.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { PropertyBinding } from './PropertyBinding.js';\nimport { PropertyMixer } from './PropertyMixer.js';\nimport { AnimationClip } from './AnimationClip.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\nclass AnimationMixer extends EventDispatcher {\n  constructor(root) {\n    super();\n    this._root = root;\n\n    this._initMemoryManager();\n\n    this._accuIndex = 0;\n    this.time = 0;\n    this.timeScale = 1.0;\n  }\n\n  _bindAction(action, prototypeAction) {\n    const root = action._localRoot || this._root,\n          tracks = action._clip.tracks,\n          nTracks = tracks.length,\n          bindings = action._propertyBindings,\n          interpolants = action._interpolants,\n          rootUuid = root.uuid,\n          bindingsByRoot = this._bindingsByRootAndName;\n    let bindingsByName = bindingsByRoot[rootUuid];\n\n    if (bindingsByName === undefined) {\n      bindingsByName = {};\n      bindingsByRoot[rootUuid] = bindingsByName;\n    }\n\n    for (let i = 0; i !== nTracks; ++i) {\n      const track = tracks[i],\n            trackName = track.name;\n      let binding = bindingsByName[trackName];\n\n      if (binding !== undefined) {\n        ++binding.referenceCount;\n        bindings[i] = binding;\n      } else {\n        binding = bindings[i];\n\n        if (binding !== undefined) {\n          // existing binding, make sure the cache knows\n          if (binding._cacheIndex === null) {\n            ++binding.referenceCount;\n\n            this._addInactiveBinding(binding, rootUuid, trackName);\n          }\n\n          continue;\n        }\n\n        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;\n        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());\n        ++binding.referenceCount;\n\n        this._addInactiveBinding(binding, rootUuid, trackName);\n\n        bindings[i] = binding;\n      }\n\n      interpolants[i].resultBuffer = binding.buffer;\n    }\n  }\n\n  _activateAction(action) {\n    if (!this._isActiveAction(action)) {\n      if (action._cacheIndex === null) {\n        // this action has been forgotten by the cache, but the user\n        // appears to be still using it -> rebind\n        const rootUuid = (action._localRoot || this._root).uuid,\n              clipUuid = action._clip.uuid,\n              actionsForClip = this._actionsByClip[clipUuid];\n\n        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);\n\n        this._addInactiveAction(action, clipUuid, rootUuid);\n      }\n\n      const bindings = action._propertyBindings; // increment reference counts / sort out state\n\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n\n        if (binding.useCount++ === 0) {\n          this._lendBinding(binding);\n\n          binding.saveOriginalState();\n        }\n      }\n\n      this._lendAction(action);\n    }\n  }\n\n  _deactivateAction(action) {\n    if (this._isActiveAction(action)) {\n      const bindings = action._propertyBindings; // decrement reference counts / sort out state\n\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n\n        if (--binding.useCount === 0) {\n          binding.restoreOriginalState();\n\n          this._takeBackBinding(binding);\n        }\n      }\n\n      this._takeBackAction(action);\n    }\n  } // Memory manager\n\n\n  _initMemoryManager() {\n    this._actions = []; // 'nActiveActions' followed by inactive ones\n\n    this._nActiveActions = 0;\n    this._actionsByClip = {}; // inside:\n    // {\n    // \tknownActions: Array< AnimationAction > - used as prototypes\n    // \tactionByRoot: AnimationAction - lookup\n    // }\n\n    this._bindings = []; // 'nActiveBindings' followed by inactive ones\n\n    this._nActiveBindings = 0;\n    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n    this._controlInterpolants = []; // same game as above\n\n    this._nActiveControlInterpolants = 0;\n    const scope = this;\n    this.stats = {\n      actions: {\n        get total() {\n          return scope._actions.length;\n        },\n\n        get inUse() {\n          return scope._nActiveActions;\n        }\n\n      },\n      bindings: {\n        get total() {\n          return scope._bindings.length;\n        },\n\n        get inUse() {\n          return scope._nActiveBindings;\n        }\n\n      },\n      controlInterpolants: {\n        get total() {\n          return scope._controlInterpolants.length;\n        },\n\n        get inUse() {\n          return scope._nActiveControlInterpolants;\n        }\n\n      }\n    };\n  } // Memory management for AnimationAction objects\n\n\n  _isActiveAction(action) {\n    const index = action._cacheIndex;\n    return index !== null && index < this._nActiveActions;\n  }\n\n  _addInactiveAction(action, clipUuid, rootUuid) {\n    const actions = this._actions,\n          actionsByClip = this._actionsByClip;\n    let actionsForClip = actionsByClip[clipUuid];\n\n    if (actionsForClip === undefined) {\n      actionsForClip = {\n        knownActions: [action],\n        actionByRoot: {}\n      };\n      action._byClipCacheIndex = 0;\n      actionsByClip[clipUuid] = actionsForClip;\n    } else {\n      const knownActions = actionsForClip.knownActions;\n      action._byClipCacheIndex = knownActions.length;\n      knownActions.push(action);\n    }\n\n    action._cacheIndex = actions.length;\n    actions.push(action);\n    actionsForClip.actionByRoot[rootUuid] = action;\n  }\n\n  _removeInactiveAction(action) {\n    const actions = this._actions,\n          lastInactiveAction = actions[actions.length - 1],\n          cacheIndex = action._cacheIndex;\n    lastInactiveAction._cacheIndex = cacheIndex;\n    actions[cacheIndex] = lastInactiveAction;\n    actions.pop();\n    action._cacheIndex = null;\n    const clipUuid = action._clip.uuid,\n          actionsByClip = this._actionsByClip,\n          actionsForClip = actionsByClip[clipUuid],\n          knownActionsForClip = actionsForClip.knownActions,\n          lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],\n          byClipCacheIndex = action._byClipCacheIndex;\n    lastKnownAction._byClipCacheIndex = byClipCacheIndex;\n    knownActionsForClip[byClipCacheIndex] = lastKnownAction;\n    knownActionsForClip.pop();\n    action._byClipCacheIndex = null;\n    const actionByRoot = actionsForClip.actionByRoot,\n          rootUuid = (action._localRoot || this._root).uuid;\n    delete actionByRoot[rootUuid];\n\n    if (knownActionsForClip.length === 0) {\n      delete actionsByClip[clipUuid];\n    }\n\n    this._removeInactiveBindingsForAction(action);\n  }\n\n  _removeInactiveBindingsForAction(action) {\n    const bindings = action._propertyBindings;\n\n    for (let i = 0, n = bindings.length; i !== n; ++i) {\n      const binding = bindings[i];\n\n      if (--binding.referenceCount === 0) {\n        this._removeInactiveBinding(binding);\n      }\n    }\n  }\n\n  _lendAction(action) {\n    // [ active actions |  inactive actions  ]\n    // [  active actions >| inactive actions ]\n    //                 s        a\n    //                  <-swap->\n    //                 a        s\n    const actions = this._actions,\n          prevIndex = action._cacheIndex,\n          lastActiveIndex = this._nActiveActions++,\n          firstInactiveAction = actions[lastActiveIndex];\n    action._cacheIndex = lastActiveIndex;\n    actions[lastActiveIndex] = action;\n    firstInactiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = firstInactiveAction;\n  }\n\n  _takeBackAction(action) {\n    // [  active actions  | inactive actions ]\n    // [ active actions |< inactive actions  ]\n    //        a        s\n    //         <-swap->\n    //        s        a\n    const actions = this._actions,\n          prevIndex = action._cacheIndex,\n          firstInactiveIndex = --this._nActiveActions,\n          lastActiveAction = actions[firstInactiveIndex];\n    action._cacheIndex = firstInactiveIndex;\n    actions[firstInactiveIndex] = action;\n    lastActiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = lastActiveAction;\n  } // Memory management for PropertyMixer objects\n\n\n  _addInactiveBinding(binding, rootUuid, trackName) {\n    const bindingsByRoot = this._bindingsByRootAndName,\n          bindings = this._bindings;\n    let bindingByName = bindingsByRoot[rootUuid];\n\n    if (bindingByName === undefined) {\n      bindingByName = {};\n      bindingsByRoot[rootUuid] = bindingByName;\n    }\n\n    bindingByName[trackName] = binding;\n    binding._cacheIndex = bindings.length;\n    bindings.push(binding);\n  }\n\n  _removeInactiveBinding(binding) {\n    const bindings = this._bindings,\n          propBinding = binding.binding,\n          rootUuid = propBinding.rootNode.uuid,\n          trackName = propBinding.path,\n          bindingsByRoot = this._bindingsByRootAndName,\n          bindingByName = bindingsByRoot[rootUuid],\n          lastInactiveBinding = bindings[bindings.length - 1],\n          cacheIndex = binding._cacheIndex;\n    lastInactiveBinding._cacheIndex = cacheIndex;\n    bindings[cacheIndex] = lastInactiveBinding;\n    bindings.pop();\n    delete bindingByName[trackName];\n\n    if (Object.keys(bindingByName).length === 0) {\n      delete bindingsByRoot[rootUuid];\n    }\n  }\n\n  _lendBinding(binding) {\n    const bindings = this._bindings,\n          prevIndex = binding._cacheIndex,\n          lastActiveIndex = this._nActiveBindings++,\n          firstInactiveBinding = bindings[lastActiveIndex];\n    binding._cacheIndex = lastActiveIndex;\n    bindings[lastActiveIndex] = binding;\n    firstInactiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = firstInactiveBinding;\n  }\n\n  _takeBackBinding(binding) {\n    const bindings = this._bindings,\n          prevIndex = binding._cacheIndex,\n          firstInactiveIndex = --this._nActiveBindings,\n          lastActiveBinding = bindings[firstInactiveIndex];\n    binding._cacheIndex = firstInactiveIndex;\n    bindings[firstInactiveIndex] = binding;\n    lastActiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = lastActiveBinding;\n  } // Memory management of Interpolants for weight and time scale\n\n\n  _lendControlInterpolant() {\n    const interpolants = this._controlInterpolants,\n          lastActiveIndex = this._nActiveControlInterpolants++;\n    let interpolant = interpolants[lastActiveIndex];\n\n    if (interpolant === undefined) {\n      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);\n      interpolant.__cacheIndex = lastActiveIndex;\n      interpolants[lastActiveIndex] = interpolant;\n    }\n\n    return interpolant;\n  }\n\n  _takeBackControlInterpolant(interpolant) {\n    const interpolants = this._controlInterpolants,\n          prevIndex = interpolant.__cacheIndex,\n          firstInactiveIndex = --this._nActiveControlInterpolants,\n          lastActiveInterpolant = interpolants[firstInactiveIndex];\n    interpolant.__cacheIndex = firstInactiveIndex;\n    interpolants[firstInactiveIndex] = interpolant;\n    lastActiveInterpolant.__cacheIndex = prevIndex;\n    interpolants[prevIndex] = lastActiveInterpolant;\n  } // return an action for a clip optionally using a custom root target\n  // object (this method allocates a lot of dynamic memory in case a\n  // previously unknown clip/root combination is specified)\n\n\n  clipAction(clip, optionalRoot, blendMode) {\n    const root = optionalRoot || this._root,\n          rootUuid = root.uuid;\n    let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;\n    const clipUuid = clipObject !== null ? clipObject.uuid : clip;\n    const actionsForClip = this._actionsByClip[clipUuid];\n    let prototypeAction = null;\n\n    if (blendMode === undefined) {\n      if (clipObject !== null) {\n        blendMode = clipObject.blendMode;\n      } else {\n        blendMode = NormalAnimationBlendMode;\n      }\n    }\n\n    if (actionsForClip !== undefined) {\n      const existingAction = actionsForClip.actionByRoot[rootUuid];\n\n      if (existingAction !== undefined && existingAction.blendMode === blendMode) {\n        return existingAction;\n      } // we know the clip, so we don't have to parse all\n      // the bindings again but can just copy\n\n\n      prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action\n\n      if (clipObject === null) clipObject = prototypeAction._clip;\n    } // clip must be known when specified via string\n\n\n    if (clipObject === null) return null; // allocate all resources required to run it\n\n    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);\n\n    this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager\n\n\n    this._addInactiveAction(newAction, clipUuid, rootUuid);\n\n    return newAction;\n  } // get an existing action\n\n\n  existingAction(clip, optionalRoot) {\n    const root = optionalRoot || this._root,\n          rootUuid = root.uuid,\n          clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,\n          clipUuid = clipObject ? clipObject.uuid : clip,\n          actionsForClip = this._actionsByClip[clipUuid];\n\n    if (actionsForClip !== undefined) {\n      return actionsForClip.actionByRoot[rootUuid] || null;\n    }\n\n    return null;\n  } // deactivates all previously scheduled actions\n\n\n  stopAllAction() {\n    const actions = this._actions,\n          nActions = this._nActiveActions;\n\n    for (let i = nActions - 1; i >= 0; --i) {\n      actions[i].stop();\n    }\n\n    return this;\n  } // advance the time and update apply the animation\n\n\n  update(deltaTime) {\n    deltaTime *= this.timeScale;\n    const actions = this._actions,\n          nActions = this._nActiveActions,\n          time = this.time += deltaTime,\n          timeDirection = Math.sign(deltaTime),\n          accuIndex = this._accuIndex ^= 1; // run active actions\n\n    for (let i = 0; i !== nActions; ++i) {\n      const action = actions[i];\n\n      action._update(time, deltaTime, timeDirection, accuIndex);\n    } // update scene graph\n\n\n    const bindings = this._bindings,\n          nBindings = this._nActiveBindings;\n\n    for (let i = 0; i !== nBindings; ++i) {\n      bindings[i].apply(accuIndex);\n    }\n\n    return this;\n  } // Allows you to seek to a specific time in an animation.\n\n\n  setTime(timeInSeconds) {\n    this.time = 0; // Zero out time attribute for AnimationMixer object;\n\n    for (let i = 0; i < this._actions.length; i++) {\n      this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n    }\n\n    return this.update(timeInSeconds); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n  } // return this mixer's root target object\n\n\n  getRoot() {\n    return this._root;\n  } // free all resources specific to a particular clip\n\n\n  uncacheClip(clip) {\n    const actions = this._actions,\n          clipUuid = clip.uuid,\n          actionsByClip = this._actionsByClip,\n          actionsForClip = actionsByClip[clipUuid];\n\n    if (actionsForClip !== undefined) {\n      // note: just calling _removeInactiveAction would mess up the\n      // iteration state and also require updating the state we can\n      // just throw away\n      const actionsToRemove = actionsForClip.knownActions;\n\n      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {\n        const action = actionsToRemove[i];\n\n        this._deactivateAction(action);\n\n        const cacheIndex = action._cacheIndex,\n              lastInactiveAction = actions[actions.length - 1];\n        action._cacheIndex = null;\n        action._byClipCacheIndex = null;\n        lastInactiveAction._cacheIndex = cacheIndex;\n        actions[cacheIndex] = lastInactiveAction;\n        actions.pop();\n\n        this._removeInactiveBindingsForAction(action);\n      }\n\n      delete actionsByClip[clipUuid];\n    }\n  } // free all resources specific to a particular root target object\n\n\n  uncacheRoot(root) {\n    const rootUuid = root.uuid,\n          actionsByClip = this._actionsByClip;\n\n    for (const clipUuid in actionsByClip) {\n      const actionByRoot = actionsByClip[clipUuid].actionByRoot,\n            action = actionByRoot[rootUuid];\n\n      if (action !== undefined) {\n        this._deactivateAction(action);\n\n        this._removeInactiveAction(action);\n      }\n    }\n\n    const bindingsByRoot = this._bindingsByRootAndName,\n          bindingByName = bindingsByRoot[rootUuid];\n\n    if (bindingByName !== undefined) {\n      for (const trackName in bindingByName) {\n        const binding = bindingByName[trackName];\n        binding.restoreOriginalState();\n\n        this._removeInactiveBinding(binding);\n      }\n    }\n  } // remove a targeted clip from the cache\n\n\n  uncacheAction(clip, optionalRoot) {\n    const action = this.existingAction(clip, optionalRoot);\n\n    if (action !== null) {\n      this._deactivateAction(action);\n\n      this._removeInactiveAction(action);\n    }\n  }\n\n}\n\nAnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);\nexport { AnimationMixer };","map":null,"metadata":{},"sourceType":"module"}