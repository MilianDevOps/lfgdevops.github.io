{"ast":null,"code":"import { Curve } from './Curve.js';\nimport * as Curves from '../curves/Curves.js';\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nclass CurvePath extends Curve {\n  constructor() {\n    super();\n    this.type = 'CurvePath';\n    this.curves = [];\n    this.autoClose = false; // Automatically closes the path\n  }\n\n  add(curve) {\n    this.curves.push(curve);\n  }\n\n  closePath() {\n    // Add a line curve if start and end of lines are not connected\n    const startPoint = this.curves[0].getPoint(0);\n    const endPoint = this.curves[this.curves.length - 1].getPoint(1);\n\n    if (!startPoint.equals(endPoint)) {\n      this.curves.push(new Curves['LineCurve'](endPoint, startPoint));\n    }\n  } // To get accurate point with reference to\n  // entire path distance at time t,\n  // following has to be done:\n  // 1. Length of each sub path have to be known\n  // 2. Locate and identify type of curve\n  // 3. Get t for the curve\n  // 4. Return curve.getPointAt(t')\n\n\n  getPoint(t, optionalTarget) {\n    const d = t * this.getLength();\n    const curveLengths = this.getCurveLengths();\n    let i = 0; // To think about boundaries points.\n\n    while (i < curveLengths.length) {\n      if (curveLengths[i] >= d) {\n        const diff = curveLengths[i] - d;\n        const curve = this.curves[i];\n        const segmentLength = curve.getLength();\n        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n        return curve.getPointAt(u, optionalTarget);\n      }\n\n      i++;\n    }\n\n    return null; // loop where sum != 0, sum > d , sum+1 <d\n  } // We cannot use the default THREE.Curve getPoint() with getLength() because in\n  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n  // getPoint() depends on getLength\n\n\n  getLength() {\n    const lens = this.getCurveLengths();\n    return lens[lens.length - 1];\n  } // cacheLengths must be recalculated.\n\n\n  updateArcLengths() {\n    this.needsUpdate = true;\n    this.cacheLengths = null;\n    this.getCurveLengths();\n  } // Compute lengths and cache them\n  // We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\n  getCurveLengths() {\n    // We use cache values if curves and cache array are same length\n    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n      return this.cacheLengths;\n    } // Get length of sub-curve\n    // Push sums into cached array\n\n\n    const lengths = [];\n    let sums = 0;\n\n    for (let i = 0, l = this.curves.length; i < l; i++) {\n      sums += this.curves[i].getLength();\n      lengths.push(sums);\n    }\n\n    this.cacheLengths = lengths;\n    return lengths;\n  }\n\n  getSpacedPoints() {\n    let divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 40;\n    const points = [];\n\n    for (let i = 0; i <= divisions; i++) {\n      points.push(this.getPoint(i / divisions));\n    }\n\n    if (this.autoClose) {\n      points.push(points[0]);\n    }\n\n    return points;\n  }\n\n  getPoints() {\n    let divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;\n    const points = [];\n    let last;\n\n    for (let i = 0, curves = this.curves; i < curves.length; i++) {\n      const curve = curves[i];\n      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;\n      const pts = curve.getPoints(resolution);\n\n      for (let j = 0; j < pts.length; j++) {\n        const point = pts[j];\n        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\n\n        points.push(point);\n        last = point;\n      }\n    }\n\n    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\n      points.push(points[0]);\n    }\n\n    return points;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.curves = [];\n\n    for (let i = 0, l = source.curves.length; i < l; i++) {\n      const curve = source.curves[i];\n      this.curves.push(curve.clone());\n    }\n\n    this.autoClose = source.autoClose;\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.autoClose = this.autoClose;\n    data.curves = [];\n\n    for (let i = 0, l = this.curves.length; i < l; i++) {\n      const curve = this.curves[i];\n      data.curves.push(curve.toJSON());\n    }\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.autoClose = json.autoClose;\n    this.curves = [];\n\n    for (let i = 0, l = json.curves.length; i < l; i++) {\n      const curve = json.curves[i];\n      this.curves.push(new Curves[curve.type]().fromJSON(curve));\n    }\n\n    return this;\n  }\n\n}\n\nexport { CurvePath };","map":null,"metadata":{},"sourceType":"module"}