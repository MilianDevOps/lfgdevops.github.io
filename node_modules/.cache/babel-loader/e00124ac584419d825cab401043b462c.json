{"ast":null,"code":"import _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { DoubleSide, BackSide } from '../constants.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\nvar _inverseMatrix = /*@__PURE__*/new Matrix4();\n\nvar _ray = /*@__PURE__*/new Ray();\n\nvar _sphere = /*@__PURE__*/new Sphere();\n\nvar _vA = /*@__PURE__*/new Vector3();\n\nvar _vB = /*@__PURE__*/new Vector3();\n\nvar _vC = /*@__PURE__*/new Vector3();\n\nvar _tempA = /*@__PURE__*/new Vector3();\n\nvar _tempB = /*@__PURE__*/new Vector3();\n\nvar _tempC = /*@__PURE__*/new Vector3();\n\nvar _morphA = /*@__PURE__*/new Vector3();\n\nvar _morphB = /*@__PURE__*/new Vector3();\n\nvar _morphC = /*@__PURE__*/new Vector3();\n\nvar _uvA = /*@__PURE__*/new Vector2();\n\nvar _uvB = /*@__PURE__*/new Vector2();\n\nvar _uvC = /*@__PURE__*/new Vector2();\n\nvar _intersectionPoint = /*@__PURE__*/new Vector3();\n\nvar _intersectionPointWorld = /*@__PURE__*/new Vector3();\n\nvar Mesh = /*#__PURE__*/function (_Object3D) {\n  _inherits(Mesh, _Object3D);\n\n  var _super = _createSuper(Mesh);\n\n  function Mesh() {\n    var _this;\n\n    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();\n    var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new MeshBasicMaterial();\n\n    _classCallCheck(this, Mesh);\n\n    _this = _super.call(this);\n    _this.type = 'Mesh';\n    _this.geometry = geometry;\n    _this.material = material;\n\n    _this.updateMorphTargets();\n\n    return _this;\n  }\n\n  _createClass(Mesh, [{\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(Mesh.prototype), \"copy\", this).call(this, source);\n\n      if (source.morphTargetInfluences !== undefined) {\n        this.morphTargetInfluences = source.morphTargetInfluences.slice();\n      }\n\n      if (source.morphTargetDictionary !== undefined) {\n        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n      }\n\n      this.material = source.material;\n      this.geometry = source.geometry;\n      return this;\n    }\n  }, {\n    key: \"updateMorphTargets\",\n    value: function updateMorphTargets() {\n      var geometry = this.geometry;\n\n      if (geometry.isBufferGeometry) {\n        var morphAttributes = geometry.morphAttributes;\n        var keys = Object.keys(morphAttributes);\n\n        if (keys.length > 0) {\n          var morphAttribute = morphAttributes[keys[0]];\n\n          if (morphAttribute !== undefined) {\n            this.morphTargetInfluences = [];\n            this.morphTargetDictionary = {};\n\n            for (var m = 0, ml = morphAttribute.length; m < ml; m++) {\n              var name = morphAttribute[m].name || String(m);\n              this.morphTargetInfluences.push(0);\n              this.morphTargetDictionary[name] = m;\n            }\n          }\n        }\n      } else {\n        var morphTargets = geometry.morphTargets;\n\n        if (morphTargets !== undefined && morphTargets.length > 0) {\n          console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n        }\n      }\n    }\n  }, {\n    key: \"raycast\",\n    value: function raycast(raycaster, intersects) {\n      var geometry = this.geometry;\n      var material = this.material;\n      var matrixWorld = this.matrixWorld;\n      if (material === undefined) return; // Checking boundingSphere distance to ray\n\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n      _sphere.copy(geometry.boundingSphere);\n\n      _sphere.applyMatrix4(matrixWorld);\n\n      if (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n      _inverseMatrix.copy(matrixWorld).invert();\n\n      _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing\n\n\n      if (geometry.boundingBox !== null) {\n        if (_ray.intersectsBox(geometry.boundingBox) === false) return;\n      }\n\n      var intersection;\n\n      if (geometry.isBufferGeometry) {\n        var index = geometry.index;\n        var position = geometry.attributes.position;\n        var morphPosition = geometry.morphAttributes.position;\n        var morphTargetsRelative = geometry.morphTargetsRelative;\n        var uv = geometry.attributes.uv;\n        var uv2 = geometry.attributes.uv2;\n        var groups = geometry.groups;\n        var drawRange = geometry.drawRange;\n\n        if (index !== null) {\n          // indexed buffer geometry\n          if (Array.isArray(material)) {\n            for (var i = 0, il = groups.length; i < il; i++) {\n              var group = groups[i];\n              var groupMaterial = material[group.materialIndex];\n              var start = Math.max(group.start, drawRange.start);\n              var end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n\n              for (var j = start, jl = end; j < jl; j += 3) {\n                var a = index.getX(j);\n                var b = index.getX(j + 1);\n                var c = index.getX(j + 2);\n                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n                if (intersection) {\n                  intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics\n\n                  intersection.face.materialIndex = group.materialIndex;\n                  intersects.push(intersection);\n                }\n              }\n            }\n          } else {\n            var _start = Math.max(0, drawRange.start);\n\n            var _end = Math.min(index.count, drawRange.start + drawRange.count);\n\n            for (var _i = _start, _il = _end; _i < _il; _i += 3) {\n              var _a = index.getX(_i);\n\n              var _b = index.getX(_i + 1);\n\n              var _c = index.getX(_i + 2);\n\n              intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a, _b, _c);\n\n              if (intersection) {\n                intersection.faceIndex = Math.floor(_i / 3); // triangle number in indexed buffer semantics\n\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else if (position !== undefined) {\n          // non-indexed buffer geometry\n          if (Array.isArray(material)) {\n            for (var _i2 = 0, _il2 = groups.length; _i2 < _il2; _i2++) {\n              var _group = groups[_i2];\n              var _groupMaterial = material[_group.materialIndex];\n\n              var _start2 = Math.max(_group.start, drawRange.start);\n\n              var _end2 = Math.min(position.count, Math.min(_group.start + _group.count, drawRange.start + drawRange.count));\n\n              for (var _j = _start2, _jl = _end2; _j < _jl; _j += 3) {\n                var _a2 = _j;\n\n                var _b2 = _j + 1;\n\n                var _c2 = _j + 2;\n\n                intersection = checkBufferGeometryIntersection(this, _groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a2, _b2, _c2);\n\n                if (intersection) {\n                  intersection.faceIndex = Math.floor(_j / 3); // triangle number in non-indexed buffer semantics\n\n                  intersection.face.materialIndex = _group.materialIndex;\n                  intersects.push(intersection);\n                }\n              }\n            }\n          } else {\n            var _start3 = Math.max(0, drawRange.start);\n\n            var _end3 = Math.min(position.count, drawRange.start + drawRange.count);\n\n            for (var _i3 = _start3, _il3 = _end3; _i3 < _il3; _i3 += 3) {\n              var _a3 = _i3;\n\n              var _b3 = _i3 + 1;\n\n              var _c3 = _i3 + 2;\n\n              intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a3, _b3, _c3);\n\n              if (intersection) {\n                intersection.faceIndex = Math.floor(_i3 / 3); // triangle number in non-indexed buffer semantics\n\n                intersects.push(intersection);\n              }\n            }\n          }\n        }\n      } else if (geometry.isGeometry) {\n        console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n      }\n    }\n  }]);\n\n  return Mesh;\n}(Object3D);\n\nMesh.prototype.isMesh = true;\n\nfunction checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {\n  var intersect;\n\n  if (material.side === BackSide) {\n    intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);\n  }\n\n  if (intersect === null) return null;\n\n  _intersectionPointWorld.copy(point);\n\n  _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n\n  var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n  if (distance < raycaster.near || distance > raycaster.far) return null;\n  return {\n    distance: distance,\n    point: _intersectionPointWorld.clone(),\n    object: object\n  };\n}\n\nfunction checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {\n  _vA.fromBufferAttribute(position, a);\n\n  _vB.fromBufferAttribute(position, b);\n\n  _vC.fromBufferAttribute(position, c);\n\n  var morphInfluences = object.morphTargetInfluences;\n\n  if (morphPosition && morphInfluences) {\n    _morphA.set(0, 0, 0);\n\n    _morphB.set(0, 0, 0);\n\n    _morphC.set(0, 0, 0);\n\n    for (var i = 0, il = morphPosition.length; i < il; i++) {\n      var influence = morphInfluences[i];\n      var morphAttribute = morphPosition[i];\n      if (influence === 0) continue;\n\n      _tempA.fromBufferAttribute(morphAttribute, a);\n\n      _tempB.fromBufferAttribute(morphAttribute, b);\n\n      _tempC.fromBufferAttribute(morphAttribute, c);\n\n      if (morphTargetsRelative) {\n        _morphA.addScaledVector(_tempA, influence);\n\n        _morphB.addScaledVector(_tempB, influence);\n\n        _morphC.addScaledVector(_tempC, influence);\n      } else {\n        _morphA.addScaledVector(_tempA.sub(_vA), influence);\n\n        _morphB.addScaledVector(_tempB.sub(_vB), influence);\n\n        _morphC.addScaledVector(_tempC.sub(_vC), influence);\n      }\n    }\n\n    _vA.add(_morphA);\n\n    _vB.add(_morphB);\n\n    _vC.add(_morphC);\n  }\n\n  if (object.isSkinnedMesh) {\n    object.boneTransform(a, _vA);\n    object.boneTransform(b, _vB);\n    object.boneTransform(c, _vC);\n  }\n\n  var intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);\n\n  if (intersection) {\n    if (uv) {\n      _uvA.fromBufferAttribute(uv, a);\n\n      _uvB.fromBufferAttribute(uv, b);\n\n      _uvC.fromBufferAttribute(uv, c);\n\n      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());\n    }\n\n    if (uv2) {\n      _uvA.fromBufferAttribute(uv2, a);\n\n      _uvB.fromBufferAttribute(uv2, b);\n\n      _uvC.fromBufferAttribute(uv2, c);\n\n      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());\n    }\n\n    var face = {\n      a: a,\n      b: b,\n      c: c,\n      normal: new Vector3(),\n      materialIndex: 0\n    };\n    Triangle.getNormal(_vA, _vB, _vC, face.normal);\n    intersection.face = face;\n  }\n\n  return intersection;\n}\n\nexport { Mesh };","map":null,"metadata":{},"sourceType":"module"}