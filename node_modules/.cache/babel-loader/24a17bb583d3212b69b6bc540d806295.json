{"ast":null,"code":"import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { DoubleSide, BackSide } from '../constants.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\nconst _inverseMatrix = /*@__PURE__*/new Matrix4();\n\nconst _ray = /*@__PURE__*/new Ray();\n\nconst _sphere = /*@__PURE__*/new Sphere();\n\nconst _vA = /*@__PURE__*/new Vector3();\n\nconst _vB = /*@__PURE__*/new Vector3();\n\nconst _vC = /*@__PURE__*/new Vector3();\n\nconst _tempA = /*@__PURE__*/new Vector3();\n\nconst _tempB = /*@__PURE__*/new Vector3();\n\nconst _tempC = /*@__PURE__*/new Vector3();\n\nconst _morphA = /*@__PURE__*/new Vector3();\n\nconst _morphB = /*@__PURE__*/new Vector3();\n\nconst _morphC = /*@__PURE__*/new Vector3();\n\nconst _uvA = /*@__PURE__*/new Vector2();\n\nconst _uvB = /*@__PURE__*/new Vector2();\n\nconst _uvC = /*@__PURE__*/new Vector2();\n\nconst _intersectionPoint = /*@__PURE__*/new Vector3();\n\nconst _intersectionPointWorld = /*@__PURE__*/new Vector3();\n\nclass Mesh extends Object3D {\n  constructor() {\n    let geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();\n    let material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new MeshBasicMaterial();\n    super();\n    this.type = 'Mesh';\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    if (source.morphTargetInfluences !== undefined) {\n      this.morphTargetInfluences = source.morphTargetInfluences.slice();\n    }\n\n    if (source.morphTargetDictionary !== undefined) {\n      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n    }\n\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n\n  updateMorphTargets() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      const morphTargets = geometry.morphTargets;\n\n      if (morphTargets !== undefined && morphTargets.length > 0) {\n        console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n      }\n    }\n  }\n\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const material = this.material;\n    const matrixWorld = this.matrixWorld;\n    if (material === undefined) return; // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere.copy(geometry.boundingSphere);\n\n    _sphere.applyMatrix4(matrixWorld);\n\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n    _inverseMatrix.copy(matrixWorld).invert();\n\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing\n\n\n    if (geometry.boundingBox !== null) {\n      if (_ray.intersectsBox(geometry.boundingBox) === false) return;\n    }\n\n    let intersection;\n\n    if (geometry.isBufferGeometry) {\n      const index = geometry.index;\n      const position = geometry.attributes.position;\n      const morphPosition = geometry.morphAttributes.position;\n      const morphTargetsRelative = geometry.morphTargetsRelative;\n      const uv = geometry.attributes.uv;\n      const uv2 = geometry.attributes.uv2;\n      const groups = geometry.groups;\n      const drawRange = geometry.drawRange;\n\n      if (index !== null) {\n        // indexed buffer geometry\n        if (Array.isArray(material)) {\n          for (let i = 0, il = groups.length; i < il; i++) {\n            const group = groups[i];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = index.getX(j);\n              const b = index.getX(j + 1);\n              const c = index.getX(j + 2);\n              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics\n\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(index.count, drawRange.start + drawRange.count);\n\n          for (let i = start, il = end; i < il; i += 3) {\n            const a = index.getX(i);\n            const b = index.getX(i + 1);\n            const c = index.getX(i + 2);\n            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics\n\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else if (position !== undefined) {\n        // non-indexed buffer geometry\n        if (Array.isArray(material)) {\n          for (let i = 0, il = groups.length; i < il; i++) {\n            const group = groups[i];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = j;\n              const b = j + 1;\n              const c = j + 2;\n              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics\n\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(position.count, drawRange.start + drawRange.count);\n\n          for (let i = start, il = end; i < il; i += 3) {\n            const a = i;\n            const b = i + 1;\n            const c = i + 2;\n            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics\n\n              intersects.push(intersection);\n            }\n          }\n        }\n      }\n    } else if (geometry.isGeometry) {\n      console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n    }\n  }\n\n}\n\nMesh.prototype.isMesh = true;\n\nfunction checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {\n  let intersect;\n\n  if (material.side === BackSide) {\n    intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);\n  }\n\n  if (intersect === null) return null;\n\n  _intersectionPointWorld.copy(point);\n\n  _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n\n  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n  if (distance < raycaster.near || distance > raycaster.far) return null;\n  return {\n    distance: distance,\n    point: _intersectionPointWorld.clone(),\n    object: object\n  };\n}\n\nfunction checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {\n  _vA.fromBufferAttribute(position, a);\n\n  _vB.fromBufferAttribute(position, b);\n\n  _vC.fromBufferAttribute(position, c);\n\n  const morphInfluences = object.morphTargetInfluences;\n\n  if (morphPosition && morphInfluences) {\n    _morphA.set(0, 0, 0);\n\n    _morphB.set(0, 0, 0);\n\n    _morphC.set(0, 0, 0);\n\n    for (let i = 0, il = morphPosition.length; i < il; i++) {\n      const influence = morphInfluences[i];\n      const morphAttribute = morphPosition[i];\n      if (influence === 0) continue;\n\n      _tempA.fromBufferAttribute(morphAttribute, a);\n\n      _tempB.fromBufferAttribute(morphAttribute, b);\n\n      _tempC.fromBufferAttribute(morphAttribute, c);\n\n      if (morphTargetsRelative) {\n        _morphA.addScaledVector(_tempA, influence);\n\n        _morphB.addScaledVector(_tempB, influence);\n\n        _morphC.addScaledVector(_tempC, influence);\n      } else {\n        _morphA.addScaledVector(_tempA.sub(_vA), influence);\n\n        _morphB.addScaledVector(_tempB.sub(_vB), influence);\n\n        _morphC.addScaledVector(_tempC.sub(_vC), influence);\n      }\n    }\n\n    _vA.add(_morphA);\n\n    _vB.add(_morphB);\n\n    _vC.add(_morphC);\n  }\n\n  if (object.isSkinnedMesh) {\n    object.boneTransform(a, _vA);\n    object.boneTransform(b, _vB);\n    object.boneTransform(c, _vC);\n  }\n\n  const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);\n\n  if (intersection) {\n    if (uv) {\n      _uvA.fromBufferAttribute(uv, a);\n\n      _uvB.fromBufferAttribute(uv, b);\n\n      _uvC.fromBufferAttribute(uv, c);\n\n      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());\n    }\n\n    if (uv2) {\n      _uvA.fromBufferAttribute(uv2, a);\n\n      _uvB.fromBufferAttribute(uv2, b);\n\n      _uvC.fromBufferAttribute(uv2, c);\n\n      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());\n    }\n\n    const face = {\n      a: a,\n      b: b,\n      c: c,\n      normal: new Vector3(),\n      materialIndex: 0\n    };\n    Triangle.getNormal(_vA, _vB, _vC, face.normal);\n    intersection.face = face;\n  }\n\n  return intersection;\n}\n\nexport { Mesh };","map":null,"metadata":{},"sourceType":"module"}