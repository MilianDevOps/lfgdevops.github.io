{"ast":null,"code":"import _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\nimport { Mesh } from './Mesh.js';\nimport { Matrix4 } from '../math/Matrix4.js';\n\nvar _instanceLocalMatrix = /*@__PURE__*/new Matrix4();\n\nvar _instanceWorldMatrix = /*@__PURE__*/new Matrix4();\n\nvar _instanceIntersects = [];\n\nvar _mesh = /*@__PURE__*/new Mesh();\n\nvar InstancedMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(InstancedMesh, _Mesh);\n\n  var _super = _createSuper(InstancedMesh);\n\n  function InstancedMesh(geometry, material, count) {\n    var _this;\n\n    _classCallCheck(this, InstancedMesh);\n\n    _this = _super.call(this, geometry, material);\n    _this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);\n    _this.instanceColor = null;\n    _this.count = count;\n    _this.frustumCulled = false;\n    return _this;\n  }\n\n  _createClass(InstancedMesh, [{\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(InstancedMesh.prototype), \"copy\", this).call(this, source);\n\n      this.instanceMatrix.copy(source.instanceMatrix);\n      if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();\n      this.count = source.count;\n      return this;\n    }\n  }, {\n    key: \"getColorAt\",\n    value: function getColorAt(index, color) {\n      color.fromArray(this.instanceColor.array, index * 3);\n    }\n  }, {\n    key: \"getMatrixAt\",\n    value: function getMatrixAt(index, matrix) {\n      matrix.fromArray(this.instanceMatrix.array, index * 16);\n    }\n  }, {\n    key: \"raycast\",\n    value: function raycast(raycaster, intersects) {\n      var matrixWorld = this.matrixWorld;\n      var raycastTimes = this.count;\n      _mesh.geometry = this.geometry;\n      _mesh.material = this.material;\n      if (_mesh.material === undefined) return;\n\n      for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {\n        // calculate the world matrix for each instance\n        this.getMatrixAt(instanceId, _instanceLocalMatrix);\n\n        _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance\n\n\n        _mesh.matrixWorld = _instanceWorldMatrix;\n\n        _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast\n\n\n        for (var i = 0, l = _instanceIntersects.length; i < l; i++) {\n          var intersect = _instanceIntersects[i];\n          intersect.instanceId = instanceId;\n          intersect.object = this;\n          intersects.push(intersect);\n        }\n\n        _instanceIntersects.length = 0;\n      }\n    }\n  }, {\n    key: \"setColorAt\",\n    value: function setColorAt(index, color) {\n      if (this.instanceColor === null) {\n        this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);\n      }\n\n      color.toArray(this.instanceColor.array, index * 3);\n    }\n  }, {\n    key: \"setMatrixAt\",\n    value: function setMatrixAt(index, matrix) {\n      matrix.toArray(this.instanceMatrix.array, index * 16);\n    }\n  }, {\n    key: \"updateMorphTargets\",\n    value: function updateMorphTargets() {}\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.dispatchEvent({\n        type: 'dispose'\n      });\n    }\n  }]);\n\n  return InstancedMesh;\n}(Mesh);\n\nInstancedMesh.prototype.isInstancedMesh = true;\nexport { InstancedMesh };","map":null,"metadata":{},"sourceType":"module"}