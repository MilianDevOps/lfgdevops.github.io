{"ast":null,"code":"import { FloatType, RGBAFormat } from '../../constants.js';\nimport { DataTexture2DArray } from '../../textures/DataTexture2DArray.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Vector2 } from '../../math/Vector2.js';\n\nfunction numericalSort(a, b) {\n  return a[0] - b[0];\n}\n\nfunction absNumericalSort(a, b) {\n  return Math.abs(b[1]) - Math.abs(a[1]);\n}\n\nfunction denormalize(morph, attribute) {\n  var denominator = 1;\n  var array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;\n  if (array instanceof Int8Array) denominator = 127;else if (array instanceof Int16Array) denominator = 32767;else if (array instanceof Int32Array) denominator = 2147483647;else console.error('THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array);\n  morph.divideScalar(denominator);\n}\n\nfunction WebGLMorphtargets(gl, capabilities, textures) {\n  var influencesList = {};\n  var morphInfluences = new Float32Array(8);\n  var morphTextures = new WeakMap();\n  var morph = new Vector3();\n  var workInfluences = [];\n\n  for (var i = 0; i < 8; i++) {\n    workInfluences[i] = [i, 0];\n  }\n\n  function update(object, geometry, material, program) {\n    var objectInfluences = object.morphTargetInfluences;\n\n    if (capabilities.isWebGL2 === true) {\n      // instead of using attributes, the WebGL 2 code path encodes morph targets\n      // into an array of data textures. Each layer represents a single morph target.\n      var numberOfMorphTargets = geometry.morphAttributes.position.length;\n      var entry = morphTextures.get(geometry);\n\n      if (entry === undefined || entry.count !== numberOfMorphTargets) {\n        var disposeTexture = function disposeTexture() {\n          texture.dispose();\n          morphTextures.delete(geometry);\n          geometry.removeEventListener('dispose', disposeTexture);\n        };\n\n        if (entry !== undefined) entry.texture.dispose();\n        var hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n        var morphTargets = geometry.morphAttributes.position;\n        var morphNormals = geometry.morphAttributes.normal || [];\n        var numberOfVertices = geometry.attributes.position.count;\n        var numberOfVertexData = hasMorphNormals === true ? 2 : 1; // (v,n) vs. (v)\n\n        var width = numberOfVertices * numberOfVertexData;\n        var height = 1;\n\n        if (width > capabilities.maxTextureSize) {\n          height = Math.ceil(width / capabilities.maxTextureSize);\n          width = capabilities.maxTextureSize;\n        }\n\n        var buffer = new Float32Array(width * height * 4 * numberOfMorphTargets);\n        var texture = new DataTexture2DArray(buffer, width, height, numberOfMorphTargets);\n        texture.format = RGBAFormat; // using RGBA since RGB might be emulated (and is thus slower)\n\n        texture.type = FloatType;\n        texture.needsUpdate = true; // fill buffer\n\n        var vertexDataStride = numberOfVertexData * 4;\n\n        for (var _i = 0; _i < numberOfMorphTargets; _i++) {\n          var morphTarget = morphTargets[_i];\n          var morphNormal = morphNormals[_i];\n          var offset = width * height * 4 * _i;\n\n          for (var j = 0; j < morphTarget.count; j++) {\n            morph.fromBufferAttribute(morphTarget, j);\n            if (morphTarget.normalized === true) denormalize(morph, morphTarget);\n            var stride = j * vertexDataStride;\n            buffer[offset + stride + 0] = morph.x;\n            buffer[offset + stride + 1] = morph.y;\n            buffer[offset + stride + 2] = morph.z;\n            buffer[offset + stride + 3] = 0;\n\n            if (hasMorphNormals === true) {\n              morph.fromBufferAttribute(morphNormal, j);\n              if (morphNormal.normalized === true) denormalize(morph, morphNormal);\n              buffer[offset + stride + 4] = morph.x;\n              buffer[offset + stride + 5] = morph.y;\n              buffer[offset + stride + 6] = morph.z;\n              buffer[offset + stride + 7] = 0;\n            }\n          }\n        }\n\n        entry = {\n          count: numberOfMorphTargets,\n          texture: texture,\n          size: new Vector2(width, height)\n        };\n        morphTextures.set(geometry, entry);\n        geometry.addEventListener('dispose', disposeTexture);\n      } //\n\n\n      var morphInfluencesSum = 0;\n\n      for (var _i2 = 0; _i2 < objectInfluences.length; _i2++) {\n        morphInfluencesSum += objectInfluences[_i2];\n      }\n\n      var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n      program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);\n      program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);\n      program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);\n    } else {\n      // When object doesn't have morph target influences defined, we treat it as a 0-length array\n      // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n      var length = objectInfluences === undefined ? 0 : objectInfluences.length;\n      var influences = influencesList[geometry.id];\n\n      if (influences === undefined || influences.length !== length) {\n        // initialise list\n        influences = [];\n\n        for (var _i3 = 0; _i3 < length; _i3++) {\n          influences[_i3] = [_i3, 0];\n        }\n\n        influencesList[geometry.id] = influences;\n      } // Collect influences\n\n\n      for (var _i4 = 0; _i4 < length; _i4++) {\n        var influence = influences[_i4];\n        influence[0] = _i4;\n        influence[1] = objectInfluences[_i4];\n      }\n\n      influences.sort(absNumericalSort);\n\n      for (var _i5 = 0; _i5 < 8; _i5++) {\n        if (_i5 < length && influences[_i5][1]) {\n          workInfluences[_i5][0] = influences[_i5][0];\n          workInfluences[_i5][1] = influences[_i5][1];\n        } else {\n          workInfluences[_i5][0] = Number.MAX_SAFE_INTEGER;\n          workInfluences[_i5][1] = 0;\n        }\n      }\n\n      workInfluences.sort(numericalSort);\n      var _morphTargets = geometry.morphAttributes.position;\n      var _morphNormals = geometry.morphAttributes.normal;\n      var _morphInfluencesSum = 0;\n\n      for (var _i6 = 0; _i6 < 8; _i6++) {\n        var _influence = workInfluences[_i6];\n        var index = _influence[0];\n        var value = _influence[1];\n\n        if (index !== Number.MAX_SAFE_INTEGER && value) {\n          if (_morphTargets && geometry.getAttribute('morphTarget' + _i6) !== _morphTargets[index]) {\n            geometry.setAttribute('morphTarget' + _i6, _morphTargets[index]);\n          }\n\n          if (_morphNormals && geometry.getAttribute('morphNormal' + _i6) !== _morphNormals[index]) {\n            geometry.setAttribute('morphNormal' + _i6, _morphNormals[index]);\n          }\n\n          morphInfluences[_i6] = value;\n          _morphInfluencesSum += value;\n        } else {\n          if (_morphTargets && geometry.hasAttribute('morphTarget' + _i6) === true) {\n            geometry.deleteAttribute('morphTarget' + _i6);\n          }\n\n          if (_morphNormals && geometry.hasAttribute('morphNormal' + _i6) === true) {\n            geometry.deleteAttribute('morphNormal' + _i6);\n          }\n\n          morphInfluences[_i6] = 0;\n        }\n      } // GLSL shader uses formula baseinfluence * base + sum(target * influence)\n      // This allows us to switch between absolute morphs and relative morphs without changing shader code\n      // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\n\n      var _morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - _morphInfluencesSum;\n\n      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', _morphBaseInfluence);\n      program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);\n    }\n  }\n\n  return {\n    update: update\n  };\n}\n\nexport { WebGLMorphtargets };","map":null,"metadata":{},"sourceType":"module"}