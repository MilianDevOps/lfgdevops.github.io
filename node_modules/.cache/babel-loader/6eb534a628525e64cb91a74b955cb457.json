{"ast":null,"code":"import * as MathUtils from './MathUtils.js';\nimport { Quaternion } from './Quaternion.js';\n\nclass Vector3 {\n  constructor() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  set(x, y, z) {\n    if (z === undefined) z = this.z; // sprite.scale.set(x,y)\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    return this;\n  }\n\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n\n  setZ(z) {\n    this.z = z;\n    return this;\n  }\n\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n\n      case 1:\n        this.y = value;\n        break;\n\n      case 2:\n        this.z = value;\n        break;\n\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n\n    return this;\n  }\n\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n\n      case 1:\n        return this.y;\n\n      case 2:\n        return this.z;\n\n      default:\n        throw new Error('index is out of range: ' + index);\n    }\n  }\n\n  clone() {\n    return new this.constructor(this.x, this.y, this.z);\n  }\n\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    return this;\n  }\n\n  add(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n      return this.addVectors(v, w);\n    }\n\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    return this;\n  }\n\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    return this;\n  }\n\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    return this;\n  }\n\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    return this;\n  }\n\n  sub(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n      return this.subVectors(v, w);\n    }\n\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    return this;\n  }\n\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    return this;\n  }\n\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    return this;\n  }\n\n  multiply(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');\n      return this.multiplyVectors(v, w);\n    }\n\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    return this;\n  }\n\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    return this;\n  }\n\n  multiplyVectors(a, b) {\n    this.x = a.x * b.x;\n    this.y = a.y * b.y;\n    this.z = a.z * b.z;\n    return this;\n  }\n\n  applyEuler(euler) {\n    if (!(euler && euler.isEuler)) {\n      console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');\n    }\n\n    return this.applyQuaternion(_quaternion.setFromEuler(euler));\n  }\n\n  applyAxisAngle(axis, angle) {\n    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));\n  }\n\n  applyMatrix3(m) {\n    const x = this.x,\n          y = this.y,\n          z = this.z;\n    const e = m.elements;\n    this.x = e[0] * x + e[3] * y + e[6] * z;\n    this.y = e[1] * x + e[4] * y + e[7] * z;\n    this.z = e[2] * x + e[5] * y + e[8] * z;\n    return this;\n  }\n\n  applyNormalMatrix(m) {\n    return this.applyMatrix3(m).normalize();\n  }\n\n  applyMatrix4(m) {\n    const x = this.x,\n          y = this.y,\n          z = this.z;\n    const e = m.elements;\n    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n    return this;\n  }\n\n  applyQuaternion(q) {\n    const x = this.x,\n          y = this.y,\n          z = this.z;\n    const qx = q.x,\n          qy = q.y,\n          qz = q.z,\n          qw = q.w; // calculate quat * vector\n\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    return this;\n  }\n\n  project(camera) {\n    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n  }\n\n  unproject(camera) {\n    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n  }\n\n  transformDirection(m) {\n    // input: THREE.Matrix4 affine matrix\n    // vector interpreted as a direction\n    const x = this.x,\n          y = this.y,\n          z = this.z;\n    const e = m.elements;\n    this.x = e[0] * x + e[4] * y + e[8] * z;\n    this.y = e[1] * x + e[5] * y + e[9] * z;\n    this.z = e[2] * x + e[6] * y + e[10] * z;\n    return this.normalize();\n  }\n\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    this.z /= v.z;\n    return this;\n  }\n\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n    return this;\n  }\n\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = Math.max(this.z, v.z);\n    return this;\n  }\n\n  clamp(min, max) {\n    // assumes min < max, componentwise\n    this.x = Math.max(min.x, Math.min(max.x, this.x));\n    this.y = Math.max(min.y, Math.min(max.y, this.y));\n    this.z = Math.max(min.z, Math.min(max.z, this.z));\n    return this;\n  }\n\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    this.z = Math.max(minVal, Math.min(maxVal, this.z));\n    return this;\n  }\n\n  clampLength(min, max) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n  }\n\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    return this;\n  }\n\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    return this;\n  }\n\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    return this;\n  }\n\n  roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n    return this;\n  }\n\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n\n  dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n  } // TODO lengthSquared?\n\n\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  }\n\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  }\n\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n  }\n\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    return this;\n  }\n\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    return this;\n  }\n\n  cross(v, w) {\n    if (w !== undefined) {\n      console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');\n      return this.crossVectors(v, w);\n    }\n\n    return this.crossVectors(this, v);\n  }\n\n  crossVectors(a, b) {\n    const ax = a.x,\n          ay = a.y,\n          az = a.z;\n    const bx = b.x,\n          by = b.y,\n          bz = b.z;\n    this.x = ay * bz - az * by;\n    this.y = az * bx - ax * bz;\n    this.z = ax * by - ay * bx;\n    return this;\n  }\n\n  projectOnVector(v) {\n    const denominator = v.lengthSq();\n    if (denominator === 0) return this.set(0, 0, 0);\n    const scalar = v.dot(this) / denominator;\n    return this.copy(v).multiplyScalar(scalar);\n  }\n\n  projectOnPlane(planeNormal) {\n    _vector.copy(this).projectOnVector(planeNormal);\n\n    return this.sub(_vector);\n  }\n\n  reflect(normal) {\n    // reflect incident vector off plane orthogonal to normal\n    // normal is assumed to have unit length\n    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));\n  }\n\n  angleTo(v) {\n    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n    if (denominator === 0) return Math.PI / 2;\n    const theta = this.dot(v) / denominator; // clamp, to handle numerical problems\n\n    return Math.acos(MathUtils.clamp(theta, -1, 1));\n  }\n\n  distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n\n  distanceToSquared(v) {\n    const dx = this.x - v.x,\n          dy = this.y - v.y,\n          dz = this.z - v.z;\n    return dx * dx + dy * dy + dz * dz;\n  }\n\n  manhattanDistanceTo(v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n  }\n\n  setFromSpherical(s) {\n    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n  }\n\n  setFromSphericalCoords(radius, phi, theta) {\n    const sinPhiRadius = Math.sin(phi) * radius;\n    this.x = sinPhiRadius * Math.sin(theta);\n    this.y = Math.cos(phi) * radius;\n    this.z = sinPhiRadius * Math.cos(theta);\n    return this;\n  }\n\n  setFromCylindrical(c) {\n    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n  }\n\n  setFromCylindricalCoords(radius, theta, y) {\n    this.x = radius * Math.sin(theta);\n    this.y = y;\n    this.z = radius * Math.cos(theta);\n    return this;\n  }\n\n  setFromMatrixPosition(m) {\n    const e = m.elements;\n    this.x = e[12];\n    this.y = e[13];\n    this.z = e[14];\n    return this;\n  }\n\n  setFromMatrixScale(m) {\n    const sx = this.setFromMatrixColumn(m, 0).length();\n    const sy = this.setFromMatrixColumn(m, 1).length();\n    const sz = this.setFromMatrixColumn(m, 2).length();\n    this.x = sx;\n    this.y = sy;\n    this.z = sz;\n    return this;\n  }\n\n  setFromMatrixColumn(m, index) {\n    return this.fromArray(m.elements, index * 4);\n  }\n\n  setFromMatrix3Column(m, index) {\n    return this.fromArray(m.elements, index * 3);\n  }\n\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z;\n  }\n\n  fromArray(array) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    return this;\n  }\n\n  toArray() {\n    let array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    return array;\n  }\n\n  fromBufferAttribute(attribute, index, offset) {\n    if (offset !== undefined) {\n      console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');\n    }\n\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n    return this;\n  }\n\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n    return this;\n  }\n\n  randomDirection() {\n    // Derived from https://mathworld.wolfram.com/SpherePointPicking.html\n    const u = (Math.random() - 0.5) * 2;\n    const t = Math.random() * Math.PI * 2;\n    const f = Math.sqrt(1 - u ** 2);\n    this.x = f * Math.cos(t);\n    this.y = f * Math.sin(t);\n    this.z = u;\n    return this;\n  }\n\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n    yield this.z;\n  }\n\n}\n\nVector3.prototype.isVector3 = true;\n\nconst _vector = /*@__PURE__*/new Vector3();\n\nconst _quaternion = /*@__PURE__*/new Quaternion();\n\nexport { Vector3 };","map":null,"metadata":{},"sourceType":"module"}