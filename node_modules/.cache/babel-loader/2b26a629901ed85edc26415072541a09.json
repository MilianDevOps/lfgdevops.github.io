{"ast":null,"code":"import _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport * as MathUtils from '../math/MathUtils.js';\nimport { StaticDrawUsage } from '../constants.js';\n\nvar InterleavedBuffer = /*#__PURE__*/function () {\n  function InterleavedBuffer(array, stride) {\n    _classCallCheck(this, InterleavedBuffer);\n\n    this.array = array;\n    this.stride = stride;\n    this.count = array !== undefined ? array.length / stride : 0;\n    this.usage = StaticDrawUsage;\n    this.updateRange = {\n      offset: 0,\n      count: -1\n    };\n    this.version = 0;\n    this.uuid = MathUtils.generateUUID();\n  }\n\n  _createClass(InterleavedBuffer, [{\n    key: \"onUploadCallback\",\n    value: function onUploadCallback() {}\n  }, {\n    key: \"needsUpdate\",\n    set: function set(value) {\n      if (value === true) this.version++;\n    }\n  }, {\n    key: \"setUsage\",\n    value: function setUsage(value) {\n      this.usage = value;\n      return this;\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      this.array = new source.array.constructor(source.array);\n      this.count = source.count;\n      this.stride = source.stride;\n      this.usage = source.usage;\n      return this;\n    }\n  }, {\n    key: \"copyAt\",\n    value: function copyAt(index1, attribute, index2) {\n      index1 *= this.stride;\n      index2 *= attribute.stride;\n\n      for (var i = 0, l = this.stride; i < l; i++) {\n        this.array[index1 + i] = attribute.array[index2 + i];\n      }\n\n      return this;\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.array.set(value, offset);\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(data) {\n      if (data.arrayBuffers === undefined) {\n        data.arrayBuffers = {};\n      }\n\n      if (this.array.buffer._uuid === undefined) {\n        this.array.buffer._uuid = MathUtils.generateUUID();\n      }\n\n      if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n        data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;\n      }\n\n      var array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);\n      var ib = new this.constructor(array, this.stride);\n      ib.setUsage(this.usage);\n      return ib;\n    }\n  }, {\n    key: \"onUpload\",\n    value: function onUpload(callback) {\n      this.onUploadCallback = callback;\n      return this;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(data) {\n      if (data.arrayBuffers === undefined) {\n        data.arrayBuffers = {};\n      } // generate UUID for array buffer if necessary\n\n\n      if (this.array.buffer._uuid === undefined) {\n        this.array.buffer._uuid = MathUtils.generateUUID();\n      }\n\n      if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n        data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));\n      } //\n\n\n      return {\n        uuid: this.uuid,\n        buffer: this.array.buffer._uuid,\n        type: this.array.constructor.name,\n        stride: this.stride\n      };\n    }\n  }]);\n\n  return InterleavedBuffer;\n}();\n\nInterleavedBuffer.prototype.isInterleavedBuffer = true;\nexport { InterleavedBuffer };","map":null,"metadata":{},"sourceType":"module"}