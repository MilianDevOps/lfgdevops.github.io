{"ast":null,"code":"import { Vector3 } from './Vector3.js';\n\nconst _v0 = /*@__PURE__*/new Vector3();\n\nconst _v1 = /*@__PURE__*/new Vector3();\n\nconst _v2 = /*@__PURE__*/new Vector3();\n\nconst _v3 = /*@__PURE__*/new Vector3();\n\nconst _vab = /*@__PURE__*/new Vector3();\n\nconst _vac = /*@__PURE__*/new Vector3();\n\nconst _vbc = /*@__PURE__*/new Vector3();\n\nconst _vap = /*@__PURE__*/new Vector3();\n\nconst _vbp = /*@__PURE__*/new Vector3();\n\nconst _vcp = /*@__PURE__*/new Vector3();\n\nclass Triangle {\n  constructor() {\n    let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n    let c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }\n\n  static getNormal(a, b, c, target) {\n    target.subVectors(c, b);\n\n    _v0.subVectors(a, b);\n\n    target.cross(_v0);\n    const targetLengthSq = target.lengthSq();\n\n    if (targetLengthSq > 0) {\n      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n    }\n\n    return target.set(0, 0, 0);\n  } // static/instance method to calculate barycentric coordinates\n  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\n\n  static getBarycoord(point, a, b, c, target) {\n    _v0.subVectors(c, a);\n\n    _v1.subVectors(b, a);\n\n    _v2.subVectors(point, a);\n\n    const dot00 = _v0.dot(_v0);\n\n    const dot01 = _v0.dot(_v1);\n\n    const dot02 = _v0.dot(_v2);\n\n    const dot11 = _v1.dot(_v1);\n\n    const dot12 = _v1.dot(_v2);\n\n    const denom = dot00 * dot11 - dot01 * dot01; // collinear or singular triangle\n\n    if (denom === 0) {\n      // arbitrary location outside of triangle?\n      // not sure if this is the best idea, maybe should be returning undefined\n      return target.set(-2, -1, -1);\n    }\n\n    const invDenom = 1 / denom;\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1\n\n    return target.set(1 - u - v, v, u);\n  }\n\n  static containsPoint(point, a, b, c) {\n    this.getBarycoord(point, a, b, c, _v3);\n    return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;\n  }\n\n  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {\n    this.getBarycoord(point, p1, p2, p3, _v3);\n    target.set(0, 0);\n    target.addScaledVector(uv1, _v3.x);\n    target.addScaledVector(uv2, _v3.y);\n    target.addScaledVector(uv3, _v3.z);\n    return target;\n  }\n\n  static isFrontFacing(a, b, c, direction) {\n    _v0.subVectors(c, b);\n\n    _v1.subVectors(a, b); // strictly front facing\n\n\n    return _v0.cross(_v1).dot(direction) < 0 ? true : false;\n  }\n\n  set(a, b, c) {\n    this.a.copy(a);\n    this.b.copy(b);\n    this.c.copy(c);\n    return this;\n  }\n\n  setFromPointsAndIndices(points, i0, i1, i2) {\n    this.a.copy(points[i0]);\n    this.b.copy(points[i1]);\n    this.c.copy(points[i2]);\n    return this;\n  }\n\n  setFromAttributeAndIndices(attribute, i0, i1, i2) {\n    this.a.fromBufferAttribute(attribute, i0);\n    this.b.fromBufferAttribute(attribute, i1);\n    this.c.fromBufferAttribute(attribute, i2);\n    return this;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(triangle) {\n    this.a.copy(triangle.a);\n    this.b.copy(triangle.b);\n    this.c.copy(triangle.c);\n    return this;\n  }\n\n  getArea() {\n    _v0.subVectors(this.c, this.b);\n\n    _v1.subVectors(this.a, this.b);\n\n    return _v0.cross(_v1).length() * 0.5;\n  }\n\n  getMidpoint(target) {\n    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n  }\n\n  getNormal(target) {\n    return Triangle.getNormal(this.a, this.b, this.c, target);\n  }\n\n  getPlane(target) {\n    return target.setFromCoplanarPoints(this.a, this.b, this.c);\n  }\n\n  getBarycoord(point, target) {\n    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n  }\n\n  getUV(point, uv1, uv2, uv3, target) {\n    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);\n  }\n\n  containsPoint(point) {\n    return Triangle.containsPoint(point, this.a, this.b, this.c);\n  }\n\n  isFrontFacing(direction) {\n    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n  }\n\n  intersectsBox(box) {\n    return box.intersectsTriangle(this);\n  }\n\n  closestPointToPoint(p, target) {\n    const a = this.a,\n          b = this.b,\n          c = this.c;\n    let v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n    // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n    // under the accompanying license; see chapter 5.1.5 for detailed explanation.\n    // basically, we're distinguishing which of the voronoi regions of the triangle\n    // the point lies in with the minimum amount of redundant computation.\n\n    _vab.subVectors(b, a);\n\n    _vac.subVectors(c, a);\n\n    _vap.subVectors(p, a);\n\n    const d1 = _vab.dot(_vap);\n\n    const d2 = _vac.dot(_vap);\n\n    if (d1 <= 0 && d2 <= 0) {\n      // vertex region of A; barycentric coords (1, 0, 0)\n      return target.copy(a);\n    }\n\n    _vbp.subVectors(p, b);\n\n    const d3 = _vab.dot(_vbp);\n\n    const d4 = _vac.dot(_vbp);\n\n    if (d3 >= 0 && d4 <= d3) {\n      // vertex region of B; barycentric coords (0, 1, 0)\n      return target.copy(b);\n    }\n\n    const vc = d1 * d4 - d3 * d2;\n\n    if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n      v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)\n\n      return target.copy(a).addScaledVector(_vab, v);\n    }\n\n    _vcp.subVectors(p, c);\n\n    const d5 = _vab.dot(_vcp);\n\n    const d6 = _vac.dot(_vcp);\n\n    if (d6 >= 0 && d5 <= d6) {\n      // vertex region of C; barycentric coords (0, 0, 1)\n      return target.copy(c);\n    }\n\n    const vb = d5 * d2 - d1 * d6;\n\n    if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n      w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)\n\n      return target.copy(a).addScaledVector(_vac, w);\n    }\n\n    const va = d3 * d6 - d5 * d4;\n\n    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n      _vbc.subVectors(c, b);\n\n      w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)\n\n      return target.copy(b).addScaledVector(_vbc, w); // edge region of BC\n    } // face region\n\n\n    const denom = 1 / (va + vb + vc); // u = va * denom\n\n    v = vb * denom;\n    w = vc * denom;\n    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n  }\n\n  equals(triangle) {\n    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n  }\n\n}\n\nexport { Triangle };","map":null,"metadata":{},"sourceType":"module"}