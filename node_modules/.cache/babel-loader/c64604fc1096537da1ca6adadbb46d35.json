{"ast":null,"code":"import _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\nexport var ExtendedTriangle = /*#__PURE__*/function (_Triangle) {\n  _inherits(ExtendedTriangle, _Triangle);\n\n  var _super = _createSuper(ExtendedTriangle);\n\n  function ExtendedTriangle() {\n    var _this;\n\n    _classCallCheck(this, ExtendedTriangle);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.isExtendedTriangle = true;\n    _this.satAxes = new Array(4).fill().map(function () {\n      return new Vector3();\n    });\n    _this.satBounds = new Array(4).fill().map(function () {\n      return new SeparatingAxisBounds();\n    });\n    _this.points = [_this.a, _this.b, _this.c];\n    _this.sphere = new Sphere();\n    _this.plane = new Plane();\n    _this.needsUpdate = false;\n    return _this;\n  }\n\n  _createClass(ExtendedTriangle, [{\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(sphere) {\n      return sphereIntersectTriangle(sphere, this);\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var a = this.a;\n      var b = this.b;\n      var c = this.c;\n      var points = this.points;\n      var satAxes = this.satAxes;\n      var satBounds = this.satBounds;\n      var axis0 = satAxes[0];\n      var sab0 = satBounds[0];\n      this.getNormal(axis0);\n      sab0.setFromPoints(axis0, points);\n      var axis1 = satAxes[1];\n      var sab1 = satBounds[1];\n      axis1.subVectors(a, b);\n      sab1.setFromPoints(axis1, points);\n      var axis2 = satAxes[2];\n      var sab2 = satBounds[2];\n      axis2.subVectors(b, c);\n      sab2.setFromPoints(axis2, points);\n      var axis3 = satAxes[3];\n      var sab3 = satBounds[3];\n      axis3.subVectors(c, a);\n      sab3.setFromPoints(axis3, points);\n      this.sphere.setFromPoints(this.points);\n      this.plane.setFromNormalAndCoplanarPoint(axis0, a);\n      this.needsUpdate = false;\n    }\n  }]);\n\n  return ExtendedTriangle;\n}(Triangle);\n\nExtendedTriangle.prototype.closestPointToSegment = function () {\n  var point1 = new Vector3();\n  var point2 = new Vector3();\n  var edge = new Line3();\n  return function distanceToSegment(segment) {\n    var target1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var target2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var start = segment.start,\n        end = segment.end;\n    var points = this.points;\n    var distSq;\n    var closestDistanceSq = Infinity; // check the triangle edges\n\n    for (var i = 0; i < 3; i++) {\n      var nexti = (i + 1) % 3;\n      edge.start.copy(points[i]);\n      edge.end.copy(points[nexti]);\n      closestPointsSegmentToSegment(edge, segment, point1, point2);\n      distSq = point1.distanceToSquared(point2);\n\n      if (distSq < closestDistanceSq) {\n        closestDistanceSq = distSq;\n        if (target1) target1.copy(point1);\n        if (target2) target2.copy(point2);\n      }\n    } // check end points\n\n\n    this.closestPointToPoint(start, point1);\n    distSq = start.distanceToSquared(point1);\n\n    if (distSq < closestDistanceSq) {\n      closestDistanceSq = distSq;\n      if (target1) target1.copy(point1);\n      if (target2) target2.copy(start);\n    }\n\n    this.closestPointToPoint(end, point1);\n    distSq = end.distanceToSquared(point1);\n\n    if (distSq < closestDistanceSq) {\n      closestDistanceSq = distSq;\n      if (target1) target1.copy(point1);\n      if (target2) target2.copy(end);\n    }\n\n    return Math.sqrt(closestDistanceSq);\n  };\n}();\n\nExtendedTriangle.prototype.intersectsTriangle = function () {\n  var saTri2 = new ExtendedTriangle();\n  var arr1 = new Array(3);\n  var arr2 = new Array(3);\n  var cachedSatBounds = new SeparatingAxisBounds();\n  var cachedSatBounds2 = new SeparatingAxisBounds();\n  var cachedAxis = new Vector3();\n  var dir1 = new Vector3();\n  var dir2 = new Vector3();\n  var tempDir = new Vector3();\n  var edge = new Line3();\n  var edge1 = new Line3();\n  var edge2 = new Line3(); // TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n  // be a line contained by both triangles if not a different special case somehow represented in the return result.\n\n  return function intersectsTriangle(other) {\n    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (this.needsUpdate) {\n      this.update();\n    }\n\n    if (!other.isExtendedTriangle) {\n      saTri2.copy(other);\n      saTri2.update();\n      other = saTri2;\n    } else if (other.needsUpdate) {\n      other.update();\n    }\n\n    var plane1 = this.plane;\n    var plane2 = other.plane;\n\n    if (Math.abs(plane1.normal.dot(plane2.normal)) > 1.0 - 1e-10) {\n      // perform separating axis intersection test only for coplanar triangles\n      var satBounds1 = this.satBounds;\n      var satAxes1 = this.satAxes;\n      arr2[0] = other.a;\n      arr2[1] = other.b;\n      arr2[2] = other.c;\n\n      for (var i = 0; i < 4; i++) {\n        var sb = satBounds1[i];\n        var sa = satAxes1[i];\n        cachedSatBounds.setFromPoints(sa, arr2);\n        if (sb.isSeparated(cachedSatBounds)) return false;\n      }\n\n      var satBounds2 = other.satBounds;\n      var satAxes2 = other.satAxes;\n      arr1[0] = this.a;\n      arr1[1] = this.b;\n      arr1[2] = this.c;\n\n      for (var _i = 0; _i < 4; _i++) {\n        var _sb = satBounds2[_i];\n        var _sa = satAxes2[_i];\n        cachedSatBounds.setFromPoints(_sa, arr1);\n        if (_sb.isSeparated(cachedSatBounds)) return false;\n      } // check crossed axes\n\n\n      for (var _i2 = 0; _i2 < 4; _i2++) {\n        var sa1 = satAxes1[_i2];\n\n        for (var i2 = 0; i2 < 4; i2++) {\n          var sa2 = satAxes2[i2];\n          cachedAxis.crossVectors(sa1, sa2);\n          cachedSatBounds.setFromPoints(cachedAxis, arr1);\n          cachedSatBounds2.setFromPoints(cachedAxis, arr2);\n          if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;\n        }\n      }\n\n      if (target) {\n        // TODO find two points that intersect on the edges and make that the result\n        console.warn('ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.');\n        target.start.set(0, 0, 0);\n        target.end.set(0, 0, 0);\n      }\n\n      return true;\n    } else {\n      // find the edge that intersects the other triangle plane\n      var points1 = this.points;\n      var found1 = false;\n      var count1 = 0;\n\n      for (var _i3 = 0; _i3 < 3; _i3++) {\n        var p1 = points1[_i3];\n        var p2 = points1[(_i3 + 1) % 3];\n        edge.start.copy(p1);\n        edge.end.copy(p2);\n        edge.delta(dir1);\n\n        if (plane2.normal.dot(dir1) === 0 && plane2.distanceToPoint(edge.start) === 0) {\n          // if the edge lies on the plane then take the line\n          edge1.copy(edge);\n          count1 = 2;\n          break;\n        } else if (plane2.intersectLine(edge, found1 ? edge1.start : edge1.end)) {\n          count1++;\n\n          if (found1) {\n            break;\n          }\n\n          found1 = true;\n        }\n      }\n\n      if (count1 !== 2) {\n        return false;\n      } // find the other triangles edge that intersects this plane\n\n\n      var points2 = other.points;\n      var found2 = false;\n      var count2 = 0;\n\n      for (var _i4 = 0; _i4 < 3; _i4++) {\n        var _p = points2[_i4];\n        var _p2 = points2[(_i4 + 1) % 3];\n        edge.start.copy(_p);\n        edge.end.copy(_p2);\n        edge.delta(dir2);\n\n        if (plane1.normal.dot(dir2) === 0 && plane1.distanceToPoint(edge.start) === 0) {\n          // if the edge lies on the plane then take the line\n          edge2.copy(edge);\n          count2 = 2;\n          break;\n        } else if (plane1.intersectLine(edge, found2 ? edge2.start : edge2.end)) {\n          count2++;\n\n          if (found2) {\n            break;\n          }\n\n          found2 = true;\n        }\n      }\n\n      if (count2 !== 2) {\n        return false;\n      } // find swap the second edge so both lines are running the same direction\n\n\n      edge1.delta(dir1);\n      edge2.delta(dir2);\n\n      if (dir1.dot(dir2) < 0) {\n        var tmp = edge2.start;\n        edge2.start = edge2.end;\n        edge2.end = tmp;\n      } // check if the edges are overlapping\n\n\n      var s1 = edge1.start.dot(dir1);\n      var e1 = edge1.end.dot(dir1);\n      var s2 = edge2.start.dot(dir1);\n      var e2 = edge2.end.dot(dir1);\n      var separated1 = e1 < s2;\n      var separated2 = s1 < e2;\n\n      if (s1 !== e2 && s2 !== e1 && separated1 === separated2) {\n        return false;\n      } // assign the target output\n\n\n      if (target) {\n        tempDir.subVectors(edge1.start, edge2.start);\n\n        if (tempDir.dot(dir1) > 0) {\n          target.start.copy(edge1.start);\n        } else {\n          target.start.copy(edge2.start);\n        }\n\n        tempDir.subVectors(edge1.end, edge2.end);\n\n        if (tempDir.dot(dir1) < 0) {\n          target.end.copy(edge1.end);\n        } else {\n          target.end.copy(edge2.end);\n        }\n      }\n\n      return true;\n    }\n  };\n}();\n\nExtendedTriangle.prototype.distanceToPoint = function () {\n  var target = new Vector3();\n  return function distanceToPoint(point) {\n    this.closestPointToPoint(point, target);\n    return point.distanceTo(target);\n  };\n}();\n\nExtendedTriangle.prototype.distanceToTriangle = function () {\n  var point = new Vector3();\n  var point2 = new Vector3();\n  var cornerFields = ['a', 'b', 'c'];\n  var line1 = new Line3();\n  var line2 = new Line3();\n  return function distanceToTriangle(other) {\n    var target1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var target2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var lineTarget = target1 || target2 ? line1 : null;\n\n    if (this.intersectsTriangle(other, lineTarget)) {\n      if (target1 || target2) {\n        if (target1) lineTarget.getCenter(target1);\n        if (target2) lineTarget.getCenter(target2);\n      }\n\n      return 0;\n    }\n\n    var closestDistanceSq = Infinity; // check all point distances\n\n    for (var i = 0; i < 3; i++) {\n      var dist = void 0;\n      var field = cornerFields[i];\n      var otherVec = other[field];\n      this.closestPointToPoint(otherVec, point);\n      dist = otherVec.distanceToSquared(point);\n\n      if (dist < closestDistanceSq) {\n        closestDistanceSq = dist;\n        if (target1) target1.copy(point);\n        if (target2) target2.copy(otherVec);\n      }\n\n      var thisVec = this[field];\n      other.closestPointToPoint(thisVec, point);\n      dist = thisVec.distanceToSquared(point);\n\n      if (dist < closestDistanceSq) {\n        closestDistanceSq = dist;\n        if (target1) target1.copy(thisVec);\n        if (target2) target2.copy(point);\n      }\n    }\n\n    for (var _i5 = 0; _i5 < 3; _i5++) {\n      var f11 = cornerFields[_i5];\n      var f12 = cornerFields[(_i5 + 1) % 3];\n      line1.set(this[f11], this[f12]);\n\n      for (var i2 = 0; i2 < 3; i2++) {\n        var f21 = cornerFields[i2];\n        var f22 = cornerFields[(i2 + 1) % 3];\n        line2.set(other[f21], other[f22]);\n        closestPointsSegmentToSegment(line1, line2, point, point2);\n\n        var _dist = point.distanceToSquared(point2);\n\n        if (_dist < closestDistanceSq) {\n          closestDistanceSq = _dist;\n          if (target1) target1.copy(point);\n          if (target2) target2.copy(point2);\n        }\n      }\n    }\n\n    return Math.sqrt(closestDistanceSq);\n  };\n}();","map":null,"metadata":{},"sourceType":"module"}