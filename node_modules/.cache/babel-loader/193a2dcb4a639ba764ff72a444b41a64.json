{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass CircleGeometry extends BufferGeometry {\n  constructor() {\n    let radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n    let thetaStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let thetaLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI * 2;\n    super();\n    this.type = 'CircleGeometry';\n    this.parameters = {\n      radius: radius,\n      segments: segments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    segments = Math.max(3, segments); // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = []; // helper variables\n\n    const vertex = new Vector3();\n    const uv = new Vector2(); // center point\n\n    vertices.push(0, 0, 0);\n    normals.push(0, 0, 1);\n    uvs.push(0.5, 0.5);\n\n    for (let s = 0, i = 3; s <= segments; s++, i += 3) {\n      const segment = thetaStart + s / segments * thetaLength; // vertex\n\n      vertex.x = radius * Math.cos(segment);\n      vertex.y = radius * Math.sin(segment);\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n      normals.push(0, 0, 1); // uvs\n\n      uv.x = (vertices[i] / radius + 1) / 2;\n      uv.y = (vertices[i + 1] / radius + 1) / 2;\n      uvs.push(uv.x, uv.y);\n    } // indices\n\n\n    for (let i = 1; i <= segments; i++) {\n      indices.push(i, i + 1, 0);\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n\n  static fromJSON(data) {\n    return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);\n  }\n\n}\n\nexport { CircleGeometry, CircleGeometry as CircleBufferGeometry };","map":null,"metadata":{},"sourceType":"module"}