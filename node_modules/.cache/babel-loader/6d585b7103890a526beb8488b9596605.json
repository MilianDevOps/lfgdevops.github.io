{"ast":null,"code":"import _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Material } from './Material.js';\nimport { cloneUniforms } from '../renderers/shaders/UniformsUtils.js';\nimport default_vertex from '../renderers/shaders/ShaderChunk/default_vertex.glsl.js';\nimport default_fragment from '../renderers/shaders/ShaderChunk/default_fragment.glsl.js';\n/**\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>\n * }\n */\n\nvar ShaderMaterial = /*#__PURE__*/function (_Material) {\n  _inherits(ShaderMaterial, _Material);\n\n  var _super = _createSuper(ShaderMaterial);\n\n  function ShaderMaterial(parameters) {\n    var _this;\n\n    _classCallCheck(this, ShaderMaterial);\n\n    _this = _super.call(this);\n    _this.type = 'ShaderMaterial';\n    _this.defines = {};\n    _this.uniforms = {};\n    _this.vertexShader = default_vertex;\n    _this.fragmentShader = default_fragment;\n    _this.linewidth = 1;\n    _this.wireframe = false;\n    _this.wireframeLinewidth = 1;\n    _this.fog = false; // set to use scene fog\n\n    _this.lights = false; // set to use scene lights\n\n    _this.clipping = false; // set to use user-defined clipping planes\n\n    _this.extensions = {\n      derivatives: false,\n      // set to use derivatives\n      fragDepth: false,\n      // set to use fragment depth values\n      drawBuffers: false,\n      // set to use draw buffers\n      shaderTextureLOD: false // set to use shader texture LOD\n\n    }; // When rendered geometry doesn't include these attributes but the material does,\n    // use these default values in WebGL. This avoids errors when buffer data is missing.\n\n    _this.defaultAttributeValues = {\n      'color': [1, 1, 1],\n      'uv': [0, 0],\n      'uv2': [0, 0]\n    };\n    _this.index0AttributeName = undefined;\n    _this.uniformsNeedUpdate = false;\n    _this.glslVersion = null;\n\n    if (parameters !== undefined) {\n      if (parameters.attributes !== undefined) {\n        console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');\n      }\n\n      _this.setValues(parameters);\n    }\n\n    return _this;\n  }\n\n  _createClass(ShaderMaterial, [{\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(ShaderMaterial.prototype), \"copy\", this).call(this, source);\n\n      this.fragmentShader = source.fragmentShader;\n      this.vertexShader = source.vertexShader;\n      this.uniforms = cloneUniforms(source.uniforms);\n      this.defines = Object.assign({}, source.defines);\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.lights = source.lights;\n      this.clipping = source.clipping;\n      this.extensions = Object.assign({}, source.extensions);\n      this.glslVersion = source.glslVersion;\n      return this;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(meta) {\n      var data = _get(_getPrototypeOf(ShaderMaterial.prototype), \"toJSON\", this).call(this, meta);\n\n      data.glslVersion = this.glslVersion;\n      data.uniforms = {};\n\n      for (var name in this.uniforms) {\n        var uniform = this.uniforms[name];\n        var value = uniform.value;\n\n        if (value && value.isTexture) {\n          data.uniforms[name] = {\n            type: 't',\n            value: value.toJSON(meta).uuid\n          };\n        } else if (value && value.isColor) {\n          data.uniforms[name] = {\n            type: 'c',\n            value: value.getHex()\n          };\n        } else if (value && value.isVector2) {\n          data.uniforms[name] = {\n            type: 'v2',\n            value: value.toArray()\n          };\n        } else if (value && value.isVector3) {\n          data.uniforms[name] = {\n            type: 'v3',\n            value: value.toArray()\n          };\n        } else if (value && value.isVector4) {\n          data.uniforms[name] = {\n            type: 'v4',\n            value: value.toArray()\n          };\n        } else if (value && value.isMatrix3) {\n          data.uniforms[name] = {\n            type: 'm3',\n            value: value.toArray()\n          };\n        } else if (value && value.isMatrix4) {\n          data.uniforms[name] = {\n            type: 'm4',\n            value: value.toArray()\n          };\n        } else {\n          data.uniforms[name] = {\n            value: value\n          }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n        }\n      }\n\n      if (Object.keys(this.defines).length > 0) data.defines = this.defines;\n      data.vertexShader = this.vertexShader;\n      data.fragmentShader = this.fragmentShader;\n      var extensions = {};\n\n      for (var key in this.extensions) {\n        if (this.extensions[key] === true) extensions[key] = true;\n      }\n\n      if (Object.keys(extensions).length > 0) data.extensions = extensions;\n      return data;\n    }\n  }]);\n\n  return ShaderMaterial;\n}(Material);\n\nShaderMaterial.prototype.isShaderMaterial = true;\nexport { ShaderMaterial };","map":null,"metadata":{},"sourceType":"module"}