{"ast":null,"code":"import _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Cache } from './Cache.js';\nimport { Loader } from './Loader.js';\nvar loading = {};\n\nvar FileLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(FileLoader, _Loader);\n\n  var _super = _createSuper(FileLoader);\n\n  function FileLoader(manager) {\n    _classCallCheck(this, FileLoader);\n\n    return _super.call(this, manager);\n  }\n\n  _createClass(FileLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this = this;\n\n      if (url === undefined) url = '';\n      if (this.path !== undefined) url = this.path + url;\n      url = this.manager.resolveURL(url);\n      var cached = Cache.get(url);\n\n      if (cached !== undefined) {\n        this.manager.itemStart(url);\n        setTimeout(function () {\n          if (onLoad) onLoad(cached);\n\n          _this.manager.itemEnd(url);\n        }, 0);\n        return cached;\n      } // Check if request is duplicate\n\n\n      if (loading[url] !== undefined) {\n        loading[url].push({\n          onLoad: onLoad,\n          onProgress: onProgress,\n          onError: onError\n        });\n        return;\n      } // Initialise array for duplicate requests\n\n\n      loading[url] = [];\n      loading[url].push({\n        onLoad: onLoad,\n        onProgress: onProgress,\n        onError: onError\n      }); // create request\n\n      var req = new Request(url, {\n        headers: new Headers(this.requestHeader),\n        credentials: this.withCredentials ? 'include' : 'same-origin' // An abort controller could be added within a future PR\n\n      }); // record states ( avoid data race )\n\n      var mimeType = this.mimeType;\n      var responseType = this.responseType; // start the fetch\n\n      fetch(req).then(function (response) {\n        if (response.status === 200 || response.status === 0) {\n          // Some browsers return HTTP Status 0 when using non-http protocol\n          // e.g. 'file://' or 'data://'. Handle as success.\n          if (response.status === 0) {\n            console.warn('THREE.FileLoader: HTTP Status 0 received.');\n          }\n\n          if (typeof ReadableStream === 'undefined' || response.body.getReader === undefined) {\n            return response;\n          }\n\n          var callbacks = loading[url];\n          var reader = response.body.getReader();\n          var contentLength = response.headers.get('Content-Length');\n          var total = contentLength ? parseInt(contentLength) : 0;\n          var lengthComputable = total !== 0;\n          var loaded = 0; // periodically read data into the new stream tracking while download progress\n\n          var stream = new ReadableStream({\n            start: function start(controller) {\n              readData();\n\n              function readData() {\n                reader.read().then(function (_ref) {\n                  var done = _ref.done,\n                      value = _ref.value;\n\n                  if (done) {\n                    controller.close();\n                  } else {\n                    loaded += value.byteLength;\n                    var event = new ProgressEvent('progress', {\n                      lengthComputable: lengthComputable,\n                      loaded: loaded,\n                      total: total\n                    });\n\n                    for (var i = 0, il = callbacks.length; i < il; i++) {\n                      var callback = callbacks[i];\n                      if (callback.onProgress) callback.onProgress(event);\n                    }\n\n                    controller.enqueue(value);\n                    readData();\n                  }\n                });\n              }\n            }\n          });\n          return new Response(stream);\n        } else {\n          throw Error(\"fetch for \\\"\".concat(response.url, \"\\\" responded with \").concat(response.status, \": \").concat(response.statusText));\n        }\n      }).then(function (response) {\n        switch (responseType) {\n          case 'arraybuffer':\n            return response.arrayBuffer();\n\n          case 'blob':\n            return response.blob();\n\n          case 'document':\n            return response.text().then(function (text) {\n              var parser = new DOMParser();\n              return parser.parseFromString(text, mimeType);\n            });\n\n          case 'json':\n            return response.json();\n\n          default:\n            if (mimeType === undefined) {\n              return response.text();\n            } else {\n              // sniff encoding\n              var re = /charset=\"?([^;\"\\s]*)\"?/i;\n              var exec = re.exec(mimeType);\n              var label = exec && exec[1] ? exec[1].toLowerCase() : undefined;\n              var decoder = new TextDecoder(label);\n              return response.arrayBuffer().then(function (ab) {\n                return decoder.decode(ab);\n              });\n            }\n\n        }\n      }).then(function (data) {\n        // Add to cache only on HTTP success, so that we do not cache\n        // error response bodies as proper responses to requests.\n        Cache.add(url, data);\n        var callbacks = loading[url];\n        delete loading[url];\n\n        for (var i = 0, il = callbacks.length; i < il; i++) {\n          var callback = callbacks[i];\n          if (callback.onLoad) callback.onLoad(data);\n        }\n      }).catch(function (err) {\n        // Abort errors and other errors are handled the same\n        var callbacks = loading[url];\n\n        if (callbacks === undefined) {\n          // When onLoad was called and url was deleted in `loading`\n          _this.manager.itemError(url);\n\n          throw err;\n        }\n\n        delete loading[url];\n\n        for (var i = 0, il = callbacks.length; i < il; i++) {\n          var callback = callbacks[i];\n          if (callback.onError) callback.onError(err);\n        }\n\n        _this.manager.itemError(url);\n      }).finally(function () {\n        _this.manager.itemEnd(url);\n      });\n      this.manager.itemStart(url);\n    }\n  }, {\n    key: \"setResponseType\",\n    value: function setResponseType(value) {\n      this.responseType = value;\n      return this;\n    }\n  }, {\n    key: \"setMimeType\",\n    value: function setMimeType(value) {\n      this.mimeType = value;\n      return this;\n    }\n  }]);\n\n  return FileLoader;\n}(Loader);\n\nexport { FileLoader };","map":null,"metadata":{},"sourceType":"module"}