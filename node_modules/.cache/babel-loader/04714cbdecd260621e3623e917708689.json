{"ast":null,"code":"import _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Curve } from './Curve.js';\nimport * as Curves from '../curves/Curves.js';\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nvar CurvePath = /*#__PURE__*/function (_Curve) {\n  _inherits(CurvePath, _Curve);\n\n  var _super = _createSuper(CurvePath);\n\n  function CurvePath() {\n    var _this;\n\n    _classCallCheck(this, CurvePath);\n\n    _this = _super.call(this);\n    _this.type = 'CurvePath';\n    _this.curves = [];\n    _this.autoClose = false; // Automatically closes the path\n\n    return _this;\n  }\n\n  _createClass(CurvePath, [{\n    key: \"add\",\n    value: function add(curve) {\n      this.curves.push(curve);\n    }\n  }, {\n    key: \"closePath\",\n    value: function closePath() {\n      // Add a line curve if start and end of lines are not connected\n      var startPoint = this.curves[0].getPoint(0);\n      var endPoint = this.curves[this.curves.length - 1].getPoint(1);\n\n      if (!startPoint.equals(endPoint)) {\n        this.curves.push(new Curves['LineCurve'](endPoint, startPoint));\n      }\n    } // To get accurate point with reference to\n    // entire path distance at time t,\n    // following has to be done:\n    // 1. Length of each sub path have to be known\n    // 2. Locate and identify type of curve\n    // 3. Get t for the curve\n    // 4. Return curve.getPointAt(t')\n\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(t, optionalTarget) {\n      var d = t * this.getLength();\n      var curveLengths = this.getCurveLengths();\n      var i = 0; // To think about boundaries points.\n\n      while (i < curveLengths.length) {\n        if (curveLengths[i] >= d) {\n          var diff = curveLengths[i] - d;\n          var curve = this.curves[i];\n          var segmentLength = curve.getLength();\n          var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n          return curve.getPointAt(u, optionalTarget);\n        }\n\n        i++;\n      }\n\n      return null; // loop where sum != 0, sum > d , sum+1 <d\n    } // We cannot use the default THREE.Curve getPoint() with getLength() because in\n    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n    // getPoint() depends on getLength\n\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      var lens = this.getCurveLengths();\n      return lens[lens.length - 1];\n    } // cacheLengths must be recalculated.\n\n  }, {\n    key: \"updateArcLengths\",\n    value: function updateArcLengths() {\n      this.needsUpdate = true;\n      this.cacheLengths = null;\n      this.getCurveLengths();\n    } // Compute lengths and cache them\n    // We cannot overwrite getLengths() because UtoT mapping uses it.\n\n  }, {\n    key: \"getCurveLengths\",\n    value: function getCurveLengths() {\n      // We use cache values if curves and cache array are same length\n      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n        return this.cacheLengths;\n      } // Get length of sub-curve\n      // Push sums into cached array\n\n\n      var lengths = [];\n      var sums = 0;\n\n      for (var i = 0, l = this.curves.length; i < l; i++) {\n        sums += this.curves[i].getLength();\n        lengths.push(sums);\n      }\n\n      this.cacheLengths = lengths;\n      return lengths;\n    }\n  }, {\n    key: \"getSpacedPoints\",\n    value: function getSpacedPoints() {\n      var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 40;\n      var points = [];\n\n      for (var i = 0; i <= divisions; i++) {\n        points.push(this.getPoint(i / divisions));\n      }\n\n      if (this.autoClose) {\n        points.push(points[0]);\n      }\n\n      return points;\n    }\n  }, {\n    key: \"getPoints\",\n    value: function getPoints() {\n      var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;\n      var points = [];\n      var last;\n\n      for (var i = 0, curves = this.curves; i < curves.length; i++) {\n        var curve = curves[i];\n        var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;\n        var pts = curve.getPoints(resolution);\n\n        for (var j = 0; j < pts.length; j++) {\n          var point = pts[j];\n          if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\n\n          points.push(point);\n          last = point;\n        }\n      }\n\n      if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\n        points.push(points[0]);\n      }\n\n      return points;\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(CurvePath.prototype), \"copy\", this).call(this, source);\n\n      this.curves = [];\n\n      for (var i = 0, l = source.curves.length; i < l; i++) {\n        var curve = source.curves[i];\n        this.curves.push(curve.clone());\n      }\n\n      this.autoClose = source.autoClose;\n      return this;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var data = _get(_getPrototypeOf(CurvePath.prototype), \"toJSON\", this).call(this);\n\n      data.autoClose = this.autoClose;\n      data.curves = [];\n\n      for (var i = 0, l = this.curves.length; i < l; i++) {\n        var curve = this.curves[i];\n        data.curves.push(curve.toJSON());\n      }\n\n      return data;\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      _get(_getPrototypeOf(CurvePath.prototype), \"fromJSON\", this).call(this, json);\n\n      this.autoClose = json.autoClose;\n      this.curves = [];\n\n      for (var i = 0, l = json.curves.length; i < l; i++) {\n        var curve = json.curves[i];\n        this.curves.push(new Curves[curve.type]().fromJSON(curve));\n      }\n\n      return this;\n    }\n  }]);\n\n  return CurvePath;\n}(Curve);\n\nexport { CurvePath };","map":null,"metadata":{},"sourceType":"module"}