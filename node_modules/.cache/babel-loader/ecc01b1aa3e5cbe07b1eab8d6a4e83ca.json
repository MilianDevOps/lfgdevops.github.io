{"ast":null,"code":"import { Cache } from './Cache.js';\nimport { Loader } from './Loader.js';\nconst loading = {};\n\nclass FileLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (url === undefined) url = '';\n    if (this.path !== undefined) url = this.path + url;\n    url = this.manager.resolveURL(url);\n    const cached = Cache.get(url);\n\n    if (cached !== undefined) {\n      this.manager.itemStart(url);\n      setTimeout(() => {\n        if (onLoad) onLoad(cached);\n        this.manager.itemEnd(url);\n      }, 0);\n      return cached;\n    } // Check if request is duplicate\n\n\n    if (loading[url] !== undefined) {\n      loading[url].push({\n        onLoad: onLoad,\n        onProgress: onProgress,\n        onError: onError\n      });\n      return;\n    } // Initialise array for duplicate requests\n\n\n    loading[url] = [];\n    loading[url].push({\n      onLoad: onLoad,\n      onProgress: onProgress,\n      onError: onError\n    }); // create request\n\n    const req = new Request(url, {\n      headers: new Headers(this.requestHeader),\n      credentials: this.withCredentials ? 'include' : 'same-origin' // An abort controller could be added within a future PR\n\n    }); // record states ( avoid data race )\n\n    const mimeType = this.mimeType;\n    const responseType = this.responseType; // start the fetch\n\n    fetch(req).then(response => {\n      if (response.status === 200 || response.status === 0) {\n        // Some browsers return HTTP Status 0 when using non-http protocol\n        // e.g. 'file://' or 'data://'. Handle as success.\n        if (response.status === 0) {\n          console.warn('THREE.FileLoader: HTTP Status 0 received.');\n        }\n\n        if (typeof ReadableStream === 'undefined' || response.body.getReader === undefined) {\n          return response;\n        }\n\n        const callbacks = loading[url];\n        const reader = response.body.getReader();\n        const contentLength = response.headers.get('Content-Length');\n        const total = contentLength ? parseInt(contentLength) : 0;\n        const lengthComputable = total !== 0;\n        let loaded = 0; // periodically read data into the new stream tracking while download progress\n\n        const stream = new ReadableStream({\n          start(controller) {\n            readData();\n\n            function readData() {\n              reader.read().then(_ref => {\n                let {\n                  done,\n                  value\n                } = _ref;\n\n                if (done) {\n                  controller.close();\n                } else {\n                  loaded += value.byteLength;\n                  const event = new ProgressEvent('progress', {\n                    lengthComputable,\n                    loaded,\n                    total\n                  });\n\n                  for (let i = 0, il = callbacks.length; i < il; i++) {\n                    const callback = callbacks[i];\n                    if (callback.onProgress) callback.onProgress(event);\n                  }\n\n                  controller.enqueue(value);\n                  readData();\n                }\n              });\n            }\n          }\n\n        });\n        return new Response(stream);\n      } else {\n        throw Error(`fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`);\n      }\n    }).then(response => {\n      switch (responseType) {\n        case 'arraybuffer':\n          return response.arrayBuffer();\n\n        case 'blob':\n          return response.blob();\n\n        case 'document':\n          return response.text().then(text => {\n            const parser = new DOMParser();\n            return parser.parseFromString(text, mimeType);\n          });\n\n        case 'json':\n          return response.json();\n\n        default:\n          if (mimeType === undefined) {\n            return response.text();\n          } else {\n            // sniff encoding\n            const re = /charset=\"?([^;\"\\s]*)\"?/i;\n            const exec = re.exec(mimeType);\n            const label = exec && exec[1] ? exec[1].toLowerCase() : undefined;\n            const decoder = new TextDecoder(label);\n            return response.arrayBuffer().then(ab => decoder.decode(ab));\n          }\n\n      }\n    }).then(data => {\n      // Add to cache only on HTTP success, so that we do not cache\n      // error response bodies as proper responses to requests.\n      Cache.add(url, data);\n      const callbacks = loading[url];\n      delete loading[url];\n\n      for (let i = 0, il = callbacks.length; i < il; i++) {\n        const callback = callbacks[i];\n        if (callback.onLoad) callback.onLoad(data);\n      }\n    }).catch(err => {\n      // Abort errors and other errors are handled the same\n      const callbacks = loading[url];\n\n      if (callbacks === undefined) {\n        // When onLoad was called and url was deleted in `loading`\n        this.manager.itemError(url);\n        throw err;\n      }\n\n      delete loading[url];\n\n      for (let i = 0, il = callbacks.length; i < il; i++) {\n        const callback = callbacks[i];\n        if (callback.onError) callback.onError(err);\n      }\n\n      this.manager.itemError(url);\n    }).finally(() => {\n      this.manager.itemEnd(url);\n    });\n    this.manager.itemStart(url);\n  }\n\n  setResponseType(value) {\n    this.responseType = value;\n    return this;\n  }\n\n  setMimeType(value) {\n    this.mimeType = value;\n    return this;\n  }\n\n}\n\nexport { FileLoader };","map":null,"metadata":{},"sourceType":"module"}