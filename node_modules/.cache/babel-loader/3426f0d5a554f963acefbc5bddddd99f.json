{"ast":null,"code":"import { Matrix3 } from './Matrix3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _vector1 = /*@__PURE__*/new Vector3();\n\nconst _vector2 = /*@__PURE__*/new Vector3();\n\nconst _normalMatrix = /*@__PURE__*/new Matrix3();\n\nclass Plane {\n  constructor() {\n    let normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(1, 0, 0);\n    let constant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    // normal is assumed to be normalized\n    this.normal = normal;\n    this.constant = constant;\n  }\n\n  set(normal, constant) {\n    this.normal.copy(normal);\n    this.constant = constant;\n    return this;\n  }\n\n  setComponents(x, y, z, w) {\n    this.normal.set(x, y, z);\n    this.constant = w;\n    return this;\n  }\n\n  setFromNormalAndCoplanarPoint(normal, point) {\n    this.normal.copy(normal);\n    this.constant = -point.dot(this.normal);\n    return this;\n  }\n\n  setFromCoplanarPoints(a, b, c) {\n    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\n    this.setFromNormalAndCoplanarPoint(normal, a);\n    return this;\n  }\n\n  copy(plane) {\n    this.normal.copy(plane.normal);\n    this.constant = plane.constant;\n    return this;\n  }\n\n  normalize() {\n    // Note: will lead to a divide by zero if the plane is invalid.\n    const inverseNormalLength = 1.0 / this.normal.length();\n    this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= inverseNormalLength;\n    return this;\n  }\n\n  negate() {\n    this.constant *= -1;\n    this.normal.negate();\n    return this;\n  }\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) + this.constant;\n  }\n\n  distanceToSphere(sphere) {\n    return this.distanceToPoint(sphere.center) - sphere.radius;\n  }\n\n  projectPoint(point, target) {\n    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);\n  }\n\n  intersectLine(line, target) {\n    const direction = line.delta(_vector1);\n    const denominator = this.normal.dot(direction);\n\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (this.distanceToPoint(line.start) === 0) {\n        return target.copy(line.start);\n      } // Unsure if this is the correct method to handle this case.\n\n\n      return null;\n    }\n\n    const t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n    if (t < 0 || t > 1) {\n      return null;\n    }\n\n    return target.copy(direction).multiplyScalar(t).add(line.start);\n  }\n\n  intersectsLine(line) {\n    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n    const startSign = this.distanceToPoint(line.start);\n    const endSign = this.distanceToPoint(line.end);\n    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n  }\n\n  intersectsBox(box) {\n    return box.intersectsPlane(this);\n  }\n\n  intersectsSphere(sphere) {\n    return sphere.intersectsPlane(this);\n  }\n\n  coplanarPoint(target) {\n    return target.copy(this.normal).multiplyScalar(-this.constant);\n  }\n\n  applyMatrix4(matrix, optionalNormalMatrix) {\n    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n\n    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n    const normal = this.normal.applyMatrix3(normalMatrix).normalize();\n    this.constant = -referencePoint.dot(normal);\n    return this;\n  }\n\n  translate(offset) {\n    this.constant -= offset.dot(this.normal);\n    return this;\n  }\n\n  equals(plane) {\n    return plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n}\n\nPlane.prototype.isPlane = true;\nexport { Plane };","map":null,"metadata":{},"sourceType":"module"}