{"ast":null,"code":"import _asyncToGenerator from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/regenerator/index.js\";\n\nfunction AmmoPhysics() {\n  return _AmmoPhysics.apply(this, arguments);\n}\n\nfunction _AmmoPhysics() {\n  _AmmoPhysics = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var AmmoLib, frameRate, collisionConfiguration, dispatcher, broadphase, solver, world, worldTransform, getShape, meshes, meshMap, addMesh, handleMesh, handleInstancedMesh, setMeshPosition, lastTime, step;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            step = function _step() {\n              var time = performance.now();\n\n              if (lastTime > 0) {\n                var delta = (time - lastTime) / 1000; // console.time( 'world.step' );\n\n                world.stepSimulation(delta, 10); // console.timeEnd( 'world.step' );\n              }\n\n              lastTime = time; //\n\n              for (var i = 0, l = meshes.length; i < l; i++) {\n                var mesh = meshes[i];\n\n                if (mesh.isInstancedMesh) {\n                  var array = mesh.instanceMatrix.array;\n                  var bodies = meshMap.get(mesh);\n\n                  for (var j = 0; j < bodies.length; j++) {\n                    var body = bodies[j];\n                    var motionState = body.getMotionState();\n                    motionState.getWorldTransform(worldTransform);\n                    var position = worldTransform.getOrigin();\n                    var quaternion = worldTransform.getRotation();\n                    compose(position, quaternion, array, j * 16);\n                  }\n\n                  mesh.instanceMatrix.needsUpdate = true;\n                } else if (mesh.isMesh) {\n                  var _body2 = meshMap.get(mesh);\n\n                  var _motionState = _body2.getMotionState();\n\n                  _motionState.getWorldTransform(worldTransform);\n\n                  var _position = worldTransform.getOrigin();\n\n                  var _quaternion = worldTransform.getRotation();\n\n                  mesh.position.set(_position.x(), _position.y(), _position.z());\n                  mesh.quaternion.set(_quaternion.x(), _quaternion.y(), _quaternion.z(), _quaternion.w());\n                }\n              }\n            };\n\n            setMeshPosition = function _setMeshPosition(mesh, position) {\n              var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n              if (mesh.isInstancedMesh) {\n                var bodies = meshMap.get(mesh);\n                var body = bodies[index];\n                body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0));\n                body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0));\n                worldTransform.setIdentity();\n                worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));\n                body.setWorldTransform(worldTransform);\n              } else if (mesh.isMesh) {\n                var _body = meshMap.get(mesh);\n\n                _body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0));\n\n                _body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0));\n\n                worldTransform.setIdentity();\n                worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));\n\n                _body.setWorldTransform(worldTransform);\n              }\n            };\n\n            handleInstancedMesh = function _handleInstancedMesh(mesh, mass, shape) {\n              var array = mesh.instanceMatrix.array;\n              var bodies = [];\n\n              for (var i = 0; i < mesh.count; i++) {\n                var index = i * 16;\n                var transform = new AmmoLib.btTransform();\n                transform.setFromOpenGLMatrix(array.slice(index, index + 16));\n                var motionState = new AmmoLib.btDefaultMotionState(transform);\n                var localInertia = new AmmoLib.btVector3(0, 0, 0);\n                shape.calculateLocalInertia(mass, localInertia);\n                var rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);\n                var body = new AmmoLib.btRigidBody(rbInfo);\n                world.addRigidBody(body);\n                bodies.push(body);\n              }\n\n              if (mass > 0) {\n                mesh.instanceMatrix.setUsage(35048); // THREE.DynamicDrawUsage = 35048\n\n                meshes.push(mesh);\n                meshMap.set(mesh, bodies);\n              }\n            };\n\n            handleMesh = function _handleMesh(mesh, mass, shape) {\n              var position = mesh.position;\n              var quaternion = mesh.quaternion;\n              var transform = new AmmoLib.btTransform();\n              transform.setIdentity();\n              transform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));\n              transform.setRotation(new AmmoLib.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));\n              var motionState = new AmmoLib.btDefaultMotionState(transform);\n              var localInertia = new AmmoLib.btVector3(0, 0, 0);\n              shape.calculateLocalInertia(mass, localInertia);\n              var rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);\n              var body = new AmmoLib.btRigidBody(rbInfo); // body.setFriction( 4 );\n\n              world.addRigidBody(body);\n\n              if (mass > 0) {\n                meshes.push(mesh);\n                meshMap.set(mesh, body);\n              }\n            };\n\n            addMesh = function _addMesh(mesh) {\n              var mass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n              var shape = getShape(mesh.geometry);\n\n              if (shape !== null) {\n                if (mesh.isInstancedMesh) {\n                  handleInstancedMesh(mesh, mass, shape);\n                } else if (mesh.isMesh) {\n                  handleMesh(mesh, mass, shape);\n                }\n              }\n            };\n\n            getShape = function _getShape(geometry) {\n              var parameters = geometry.parameters; // TODO change type to is*\n\n              if (geometry.type === 'BoxGeometry') {\n                var sx = parameters.width !== undefined ? parameters.width / 2 : 0.5;\n                var sy = parameters.height !== undefined ? parameters.height / 2 : 0.5;\n                var sz = parameters.depth !== undefined ? parameters.depth / 2 : 0.5;\n                var shape = new AmmoLib.btBoxShape(new AmmoLib.btVector3(sx, sy, sz));\n                shape.setMargin(0.05);\n                return shape;\n              } else if (geometry.type === 'SphereGeometry' || geometry.type === 'IcosahedronGeometry') {\n                var radius = parameters.radius !== undefined ? parameters.radius : 1;\n\n                var _shape = new AmmoLib.btSphereShape(radius);\n\n                _shape.setMargin(0.05);\n\n                return _shape;\n              }\n\n              return null;\n            };\n\n            if (!('Ammo' in window === false)) {\n              _context.next = 9;\n              break;\n            }\n\n            console.error(\"AmmoPhysics: Couldn't find Ammo.js\");\n            return _context.abrupt(\"return\");\n\n          case 9:\n            _context.next = 11;\n            return Ammo();\n\n          case 11:\n            AmmoLib = _context.sent;\n            // eslint-disable-line no-undef\n            frameRate = 60;\n            collisionConfiguration = new AmmoLib.btDefaultCollisionConfiguration();\n            dispatcher = new AmmoLib.btCollisionDispatcher(collisionConfiguration);\n            broadphase = new AmmoLib.btDbvtBroadphase();\n            solver = new AmmoLib.btSequentialImpulseConstraintSolver();\n            world = new AmmoLib.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);\n            world.setGravity(new AmmoLib.btVector3(0, -9.8, 0));\n            worldTransform = new AmmoLib.btTransform(); //\n\n            meshes = [];\n            meshMap = new WeakMap();\n            //\n            lastTime = 0;\n            // animate\n            setInterval(step, 1000 / frameRate);\n            return _context.abrupt(\"return\", {\n              addMesh: addMesh,\n              setMeshPosition: setMeshPosition // addCompoundMesh\n\n            });\n\n          case 25:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _AmmoPhysics.apply(this, arguments);\n}\n\nfunction compose(position, quaternion, array, index) {\n  var x = quaternion.x(),\n      y = quaternion.y(),\n      z = quaternion.z(),\n      w = quaternion.w();\n  var x2 = x + x,\n      y2 = y + y,\n      z2 = z + z;\n  var xx = x * x2,\n      xy = x * y2,\n      xz = x * z2;\n  var yy = y * y2,\n      yz = y * z2,\n      zz = z * z2;\n  var wx = w * x2,\n      wy = w * y2,\n      wz = w * z2;\n  array[index + 0] = 1 - (yy + zz);\n  array[index + 1] = xy + wz;\n  array[index + 2] = xz - wy;\n  array[index + 3] = 0;\n  array[index + 4] = xy - wz;\n  array[index + 5] = 1 - (xx + zz);\n  array[index + 6] = yz + wx;\n  array[index + 7] = 0;\n  array[index + 8] = xz + wy;\n  array[index + 9] = yz - wx;\n  array[index + 10] = 1 - (xx + yy);\n  array[index + 11] = 0;\n  array[index + 12] = position.x();\n  array[index + 13] = position.y();\n  array[index + 14] = position.z();\n  array[index + 15] = 1;\n}\n\nexport { AmmoPhysics };","map":null,"metadata":{},"sourceType":"module"}