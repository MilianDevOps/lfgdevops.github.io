{"ast":null,"code":"import _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Shape } from '../extras/core/Shape.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nvar ShapeGeometry = /*#__PURE__*/function (_BufferGeometry) {\n  _inherits(ShapeGeometry, _BufferGeometry);\n\n  var _super = _createSuper(ShapeGeometry);\n\n  function ShapeGeometry() {\n    var _this;\n\n    var shapes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);\n    var curveSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;\n\n    _classCallCheck(this, ShapeGeometry);\n\n    _this = _super.call(this);\n    _this.type = 'ShapeGeometry';\n    _this.parameters = {\n      shapes: shapes,\n      curveSegments: curveSegments\n    }; // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helper variables\n\n    var groupStart = 0;\n    var groupCount = 0; // allow single and array values for \"shapes\" parameter\n\n    if (Array.isArray(shapes) === false) {\n      addShape(shapes);\n    } else {\n      for (var i = 0; i < shapes.length; i++) {\n        addShape(shapes[i]);\n\n        _this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support\n\n\n        groupStart += groupCount;\n        groupCount = 0;\n      }\n    } // build geometry\n\n\n    _this.setIndex(indices);\n\n    _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\n    _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\n    _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions\n\n\n    function addShape(shape) {\n      var indexOffset = vertices.length / 3;\n      var points = shape.extractPoints(curveSegments);\n      var shapeVertices = points.shape;\n      var shapeHoles = points.holes; // check direction of vertices\n\n      if (ShapeUtils.isClockWise(shapeVertices) === false) {\n        shapeVertices = shapeVertices.reverse();\n      }\n\n      for (var _i = 0, l = shapeHoles.length; _i < l; _i++) {\n        var shapeHole = shapeHoles[_i];\n\n        if (ShapeUtils.isClockWise(shapeHole) === true) {\n          shapeHoles[_i] = shapeHole.reverse();\n        }\n      }\n\n      var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array\n\n      for (var _i2 = 0, _l = shapeHoles.length; _i2 < _l; _i2++) {\n        var _shapeHole = shapeHoles[_i2];\n        shapeVertices = shapeVertices.concat(_shapeHole);\n      } // vertices, normals, uvs\n\n\n      for (var _i3 = 0, _l2 = shapeVertices.length; _i3 < _l2; _i3++) {\n        var vertex = shapeVertices[_i3];\n        vertices.push(vertex.x, vertex.y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(vertex.x, vertex.y); // world uvs\n      } // incides\n\n\n      for (var _i4 = 0, _l3 = faces.length; _i4 < _l3; _i4++) {\n        var face = faces[_i4];\n        var a = face[0] + indexOffset;\n        var b = face[1] + indexOffset;\n        var c = face[2] + indexOffset;\n        indices.push(a, b, c);\n        groupCount += 3;\n      }\n    }\n\n    return _this;\n  }\n\n  _createClass(ShapeGeometry, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      var data = _get(_getPrototypeOf(ShapeGeometry.prototype), \"toJSON\", this).call(this);\n\n      var shapes = this.parameters.shapes;\n      return _toJSON(shapes, data);\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(data, shapes) {\n      var geometryShapes = [];\n\n      for (var j = 0, jl = data.shapes.length; j < jl; j++) {\n        var shape = shapes[data.shapes[j]];\n        geometryShapes.push(shape);\n      }\n\n      return new ShapeGeometry(geometryShapes, data.curveSegments);\n    }\n  }]);\n\n  return ShapeGeometry;\n}(BufferGeometry);\n\nfunction _toJSON(shapes, data) {\n  data.shapes = [];\n\n  if (Array.isArray(shapes)) {\n    for (var i = 0, l = shapes.length; i < l; i++) {\n      var shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n\n  return data;\n}\n\nexport { ShapeGeometry, ShapeGeometry as ShapeBufferGeometry };","map":null,"metadata":{},"sourceType":"module"}