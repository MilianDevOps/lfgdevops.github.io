{"ast":null,"code":"import { Quaternion } from '../math/Quaternion.js';\nimport { AdditiveAnimationBlendMode } from '../constants.js';\nconst AnimationUtils = {\n  // same as Array.prototype.slice, but also works on typed arrays\n  arraySlice: function (array, from, to) {\n    if (AnimationUtils.isTypedArray(array)) {\n      // in ios9 array.subarray(from, undefined) will return empty array\n      // but array.subarray(from) or array.subarray(from, len) is correct\n      return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));\n    }\n\n    return array.slice(from, to);\n  },\n  // converts an array to a specific type\n  convertArray: function (array, type, forceClone) {\n    if (!array || // let 'undefined' and 'null' pass\n    !forceClone && array.constructor === type) return array;\n\n    if (typeof type.BYTES_PER_ELEMENT === 'number') {\n      return new type(array); // create typed array\n    }\n\n    return Array.prototype.slice.call(array); // create Array\n  },\n  isTypedArray: function (object) {\n    return ArrayBuffer.isView(object) && !(object instanceof DataView);\n  },\n  // returns an array by which times and values can be sorted\n  getKeyframeOrder: function (times) {\n    function compareTime(i, j) {\n      return times[i] - times[j];\n    }\n\n    const n = times.length;\n    const result = new Array(n);\n\n    for (let i = 0; i !== n; ++i) result[i] = i;\n\n    result.sort(compareTime);\n    return result;\n  },\n  // uses the array previously returned by 'getKeyframeOrder' to sort data\n  sortedArray: function (values, stride, order) {\n    const nValues = values.length;\n    const result = new values.constructor(nValues);\n\n    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {\n      const srcOffset = order[i] * stride;\n\n      for (let j = 0; j !== stride; ++j) {\n        result[dstOffset++] = values[srcOffset + j];\n      }\n    }\n\n    return result;\n  },\n  // function for parsing AOS keyframe formats\n  flattenJSON: function (jsonKeys, times, values, valuePropertyName) {\n    let i = 1,\n        key = jsonKeys[0];\n\n    while (key !== undefined && key[valuePropertyName] === undefined) {\n      key = jsonKeys[i++];\n    }\n\n    if (key === undefined) return; // no data\n\n    let value = key[valuePropertyName];\n    if (value === undefined) return; // no data\n\n    if (Array.isArray(value)) {\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          values.push.apply(values, value); // push all elements\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    } else if (value.toArray !== undefined) {\n      // ...assume THREE.Math-ish\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          value.toArray(values, values.length);\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    } else {\n      // otherwise push as-is\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          values.push(value);\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    }\n  },\n  subclip: function (sourceClip, name, startFrame, endFrame) {\n    let fps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 30;\n    const clip = sourceClip.clone();\n    clip.name = name;\n    const tracks = [];\n\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      const track = clip.tracks[i];\n      const valueSize = track.getValueSize();\n      const times = [];\n      const values = [];\n\n      for (let j = 0; j < track.times.length; ++j) {\n        const frame = track.times[j] * fps;\n        if (frame < startFrame || frame >= endFrame) continue;\n        times.push(track.times[j]);\n\n        for (let k = 0; k < valueSize; ++k) {\n          values.push(track.values[j * valueSize + k]);\n        }\n      }\n\n      if (times.length === 0) continue;\n      track.times = AnimationUtils.convertArray(times, track.times.constructor);\n      track.values = AnimationUtils.convertArray(values, track.values.constructor);\n      tracks.push(track);\n    }\n\n    clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip\n\n    let minStartTime = Infinity;\n\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      if (minStartTime > clip.tracks[i].times[0]) {\n        minStartTime = clip.tracks[i].times[0];\n      }\n    } // shift all tracks such that clip begins at t=0\n\n\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      clip.tracks[i].shift(-1 * minStartTime);\n    }\n\n    clip.resetDuration();\n    return clip;\n  },\n  makeClipAdditive: function (targetClip) {\n    let referenceFrame = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let referenceClip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : targetClip;\n    let fps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30;\n    if (fps <= 0) fps = 30;\n    const numTracks = referenceClip.tracks.length;\n    const referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame\n\n    for (let i = 0; i < numTracks; ++i) {\n      const referenceTrack = referenceClip.tracks[i];\n      const referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric\n\n      if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue; // Find the track in the target clip whose name and type matches the reference track\n\n      const targetTrack = targetClip.tracks.find(function (track) {\n        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;\n      });\n      if (targetTrack === undefined) continue;\n      let referenceOffset = 0;\n      const referenceValueSize = referenceTrack.getValueSize();\n\n      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        referenceOffset = referenceValueSize / 3;\n      }\n\n      let targetOffset = 0;\n      const targetValueSize = targetTrack.getValueSize();\n\n      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        targetOffset = targetValueSize / 3;\n      }\n\n      const lastIndex = referenceTrack.times.length - 1;\n      let referenceValue; // Find the value to subtract out of the track\n\n      if (referenceTime <= referenceTrack.times[0]) {\n        // Reference frame is earlier than the first keyframe, so just use the first keyframe\n        const startIndex = referenceOffset;\n        const endIndex = referenceValueSize - referenceOffset;\n        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n      } else if (referenceTime >= referenceTrack.times[lastIndex]) {\n        // Reference frame is after the last keyframe, so just use the last keyframe\n        const startIndex = lastIndex * referenceValueSize + referenceOffset;\n        const endIndex = startIndex + referenceValueSize - referenceOffset;\n        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n      } else {\n        // Interpolate to the reference value\n        const interpolant = referenceTrack.createInterpolant();\n        const startIndex = referenceOffset;\n        const endIndex = referenceValueSize - referenceOffset;\n        interpolant.evaluate(referenceTime);\n        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);\n      } // Conjugate the quaternion\n\n\n      if (referenceTrackType === 'quaternion') {\n        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();\n        referenceQuat.toArray(referenceValue);\n      } // Subtract the reference value from all of the track values\n\n\n      const numTimes = targetTrack.times.length;\n\n      for (let j = 0; j < numTimes; ++j) {\n        const valueStart = j * targetValueSize + targetOffset;\n\n        if (referenceTrackType === 'quaternion') {\n          // Multiply the conjugate for quaternion track types\n          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);\n        } else {\n          const valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types\n\n          for (let k = 0; k < valueEnd; ++k) {\n            targetTrack.values[valueStart + k] -= referenceValue[k];\n          }\n        }\n      }\n    }\n\n    targetClip.blendMode = AdditiveAnimationBlendMode;\n    return targetClip;\n  }\n};\nexport { AnimationUtils };","map":null,"metadata":{},"sourceType":"module"}