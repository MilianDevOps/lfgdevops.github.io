{"ast":null,"code":"import * as MathUtils from './MathUtils.js';\n\nclass Quaternion {\n  constructor() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n  }\n\n  static slerp(qa, qb, qm, t) {\n    console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');\n    return qm.slerpQuaternions(qa, qb, t);\n  }\n\n  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n    // fuzz-free, array-based Quaternion SLERP operation\n    let x0 = src0[srcOffset0 + 0],\n        y0 = src0[srcOffset0 + 1],\n        z0 = src0[srcOffset0 + 2],\n        w0 = src0[srcOffset0 + 3];\n    const x1 = src1[srcOffset1 + 0],\n          y1 = src1[srcOffset1 + 1],\n          z1 = src1[srcOffset1 + 2],\n          w1 = src1[srcOffset1 + 3];\n\n    if (t === 0) {\n      dst[dstOffset + 0] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n      return;\n    }\n\n    if (t === 1) {\n      dst[dstOffset + 0] = x1;\n      dst[dstOffset + 1] = y1;\n      dst[dstOffset + 2] = z1;\n      dst[dstOffset + 3] = w1;\n      return;\n    }\n\n    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n      let s = 1 - t;\n      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n            dir = cos >= 0 ? 1 : -1,\n            sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:\n\n      if (sqrSin > Number.EPSILON) {\n        const sin = Math.sqrt(sqrSin),\n              len = Math.atan2(sin, cos * dir);\n        s = Math.sin(s * len) / sin;\n        t = Math.sin(t * len) / sin;\n      }\n\n      const tDir = t * dir;\n      x0 = x0 * s + x1 * tDir;\n      y0 = y0 * s + y1 * tDir;\n      z0 = z0 * s + z1 * tDir;\n      w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:\n\n      if (s === 1 - t) {\n        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n        x0 *= f;\n        y0 *= f;\n        z0 *= f;\n        w0 *= f;\n      }\n    }\n\n    dst[dstOffset] = x0;\n    dst[dstOffset + 1] = y0;\n    dst[dstOffset + 2] = z0;\n    dst[dstOffset + 3] = w0;\n  }\n\n  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n    const x0 = src0[srcOffset0];\n    const y0 = src0[srcOffset0 + 1];\n    const z0 = src0[srcOffset0 + 2];\n    const w0 = src0[srcOffset0 + 3];\n    const x1 = src1[srcOffset1];\n    const y1 = src1[srcOffset1 + 1];\n    const z1 = src1[srcOffset1 + 2];\n    const w1 = src1[srcOffset1 + 3];\n    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n    return dst;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  set x(value) {\n    this._x = value;\n\n    this._onChangeCallback();\n  }\n\n  get y() {\n    return this._y;\n  }\n\n  set y(value) {\n    this._y = value;\n\n    this._onChangeCallback();\n  }\n\n  get z() {\n    return this._z;\n  }\n\n  set z(value) {\n    this._z = value;\n\n    this._onChangeCallback();\n  }\n\n  get w() {\n    return this._w;\n  }\n\n  set w(value) {\n    this._w = value;\n\n    this._onChangeCallback();\n  }\n\n  set(x, y, z, w) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(this._x, this._y, this._z, this._w);\n  }\n\n  copy(quaternion) {\n    this._x = quaternion.x;\n    this._y = quaternion.y;\n    this._z = quaternion.z;\n    this._w = quaternion.w;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  setFromEuler(euler, update) {\n    if (!(euler && euler.isEuler)) {\n      throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');\n    }\n\n    const x = euler._x,\n          y = euler._y,\n          z = euler._z,\n          order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/\n    // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n    //\tcontent/SpinCalc.m\n\n    const cos = Math.cos;\n    const sin = Math.sin;\n    const c1 = cos(x / 2);\n    const c2 = cos(y / 2);\n    const c3 = cos(z / 2);\n    const s1 = sin(x / 2);\n    const s2 = sin(y / 2);\n    const s3 = sin(z / 2);\n\n    switch (order) {\n      case 'XYZ':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n\n      case 'YXZ':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n\n      case 'ZXY':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n\n      case 'ZYX':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n\n      case 'YZX':\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n\n      case 'XZY':\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n\n      default:\n        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);\n    }\n\n    if (update !== false) this._onChangeCallback();\n    return this;\n  }\n\n  setFromAxisAngle(axis, angle) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n    // assumes axis is normalized\n    const halfAngle = angle / 2,\n          s = Math.sin(halfAngle);\n    this._x = axis.x * s;\n    this._y = axis.y * s;\n    this._z = axis.z * s;\n    this._w = Math.cos(halfAngle);\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  setFromRotationMatrix(m) {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n    const te = m.elements,\n          m11 = te[0],\n          m12 = te[4],\n          m13 = te[8],\n          m21 = te[1],\n          m22 = te[5],\n          m23 = te[9],\n          m31 = te[2],\n          m32 = te[6],\n          m33 = te[10],\n          trace = m11 + m22 + m33;\n\n    if (trace > 0) {\n      const s = 0.5 / Math.sqrt(trace + 1.0);\n      this._w = 0.25 / s;\n      this._x = (m32 - m23) * s;\n      this._y = (m13 - m31) * s;\n      this._z = (m21 - m12) * s;\n    } else if (m11 > m22 && m11 > m33) {\n      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n      this._w = (m32 - m23) / s;\n      this._x = 0.25 * s;\n      this._y = (m12 + m21) / s;\n      this._z = (m13 + m31) / s;\n    } else if (m22 > m33) {\n      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n      this._w = (m13 - m31) / s;\n      this._x = (m12 + m21) / s;\n      this._y = 0.25 * s;\n      this._z = (m23 + m32) / s;\n    } else {\n      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n      this._w = (m21 - m12) / s;\n      this._x = (m13 + m31) / s;\n      this._y = (m23 + m32) / s;\n      this._z = 0.25 * s;\n    }\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  setFromUnitVectors(vFrom, vTo) {\n    // assumes direction vectors vFrom and vTo are normalized\n    let r = vFrom.dot(vTo) + 1;\n\n    if (r < Number.EPSILON) {\n      // vFrom and vTo point in opposite directions\n      r = 0;\n\n      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n        this._x = -vFrom.y;\n        this._y = vFrom.x;\n        this._z = 0;\n        this._w = r;\n      } else {\n        this._x = 0;\n        this._y = -vFrom.z;\n        this._z = vFrom.y;\n        this._w = r;\n      }\n    } else {\n      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n      this._w = r;\n    }\n\n    return this.normalize();\n  }\n\n  angleTo(q) {\n    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));\n  }\n\n  rotateTowards(q, step) {\n    const angle = this.angleTo(q);\n    if (angle === 0) return this;\n    const t = Math.min(1, step / angle);\n    this.slerp(q, t);\n    return this;\n  }\n\n  identity() {\n    return this.set(0, 0, 0, 1);\n  }\n\n  invert() {\n    // quaternion is assumed to have unit length\n    return this.conjugate();\n  }\n\n  conjugate() {\n    this._x *= -1;\n    this._y *= -1;\n    this._z *= -1;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  dot(v) {\n    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n  }\n\n  lengthSq() {\n    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n  }\n\n  length() {\n    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n  }\n\n  normalize() {\n    let l = this.length();\n\n    if (l === 0) {\n      this._x = 0;\n      this._y = 0;\n      this._z = 0;\n      this._w = 1;\n    } else {\n      l = 1 / l;\n      this._x = this._x * l;\n      this._y = this._y * l;\n      this._z = this._z * l;\n      this._w = this._w * l;\n    }\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  multiply(q, p) {\n    if (p !== undefined) {\n      console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');\n      return this.multiplyQuaternions(q, p);\n    }\n\n    return this.multiplyQuaternions(this, q);\n  }\n\n  premultiply(q) {\n    return this.multiplyQuaternions(q, this);\n  }\n\n  multiplyQuaternions(a, b) {\n    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n    const qax = a._x,\n          qay = a._y,\n          qaz = a._z,\n          qaw = a._w;\n    const qbx = b._x,\n          qby = b._y,\n          qbz = b._z,\n          qbw = b._w;\n    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  slerp(qb, t) {\n    if (t === 0) return this;\n    if (t === 1) return this.copy(qb);\n    const x = this._x,\n          y = this._y,\n          z = this._z,\n          w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n    if (cosHalfTheta < 0) {\n      this._w = -qb._w;\n      this._x = -qb._x;\n      this._y = -qb._y;\n      this._z = -qb._z;\n      cosHalfTheta = -cosHalfTheta;\n    } else {\n      this.copy(qb);\n    }\n\n    if (cosHalfTheta >= 1.0) {\n      this._w = w;\n      this._x = x;\n      this._y = y;\n      this._z = z;\n      return this;\n    }\n\n    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n    if (sqrSinHalfTheta <= Number.EPSILON) {\n      const s = 1 - t;\n      this._w = s * w + t * this._w;\n      this._x = s * x + t * this._x;\n      this._y = s * y + t * this._y;\n      this._z = s * z + t * this._z;\n      this.normalize();\n\n      this._onChangeCallback();\n\n      return this;\n    }\n\n    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\n          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n    this._w = w * ratioA + this._w * ratioB;\n    this._x = x * ratioA + this._x * ratioB;\n    this._y = y * ratioA + this._y * ratioB;\n    this._z = z * ratioA + this._z * ratioB;\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  slerpQuaternions(qa, qb, t) {\n    return this.copy(qa).slerp(qb, t);\n  }\n\n  random() {\n    // Derived from http://planning.cs.uiuc.edu/node198.html\n    // Note, this source uses w, x, y, z ordering,\n    // so we swap the order below.\n    const u1 = Math.random();\n    const sqrt1u1 = Math.sqrt(1 - u1);\n    const sqrtu1 = Math.sqrt(u1);\n    const u2 = 2 * Math.PI * Math.random();\n    const u3 = 2 * Math.PI * Math.random();\n    return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));\n  }\n\n  equals(quaternion) {\n    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n  }\n\n  fromArray(array) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this._x = array[offset];\n    this._y = array[offset + 1];\n    this._z = array[offset + 2];\n    this._w = array[offset + 3];\n\n    this._onChangeCallback();\n\n    return this;\n  }\n\n  toArray() {\n    let array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._w;\n    return array;\n  }\n\n  fromBufferAttribute(attribute, index) {\n    this._x = attribute.getX(index);\n    this._y = attribute.getY(index);\n    this._z = attribute.getZ(index);\n    this._w = attribute.getW(index);\n    return this;\n  }\n\n  _onChange(callback) {\n    this._onChangeCallback = callback;\n    return this;\n  }\n\n  _onChangeCallback() {}\n\n}\n\nQuaternion.prototype.isQuaternion = true;\nexport { Quaternion };","map":null,"metadata":{},"sourceType":"module"}