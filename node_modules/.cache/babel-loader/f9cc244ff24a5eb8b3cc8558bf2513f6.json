{"ast":null,"code":"import { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { InterleavedBuffer } from '../core/InterleavedBuffer.js';\nimport { InterleavedBufferAttribute } from '../core/InterleavedBufferAttribute.js';\nimport { SpriteMaterial } from '../materials/SpriteMaterial.js';\n\nlet _geometry;\n\nconst _intersectPoint = /*@__PURE__*/new Vector3();\n\nconst _worldScale = /*@__PURE__*/new Vector3();\n\nconst _mvPosition = /*@__PURE__*/new Vector3();\n\nconst _alignedPosition = /*@__PURE__*/new Vector2();\n\nconst _rotatedPosition = /*@__PURE__*/new Vector2();\n\nconst _viewWorldMatrix = /*@__PURE__*/new Matrix4();\n\nconst _vA = /*@__PURE__*/new Vector3();\n\nconst _vB = /*@__PURE__*/new Vector3();\n\nconst _vC = /*@__PURE__*/new Vector3();\n\nconst _uvA = /*@__PURE__*/new Vector2();\n\nconst _uvB = /*@__PURE__*/new Vector2();\n\nconst _uvC = /*@__PURE__*/new Vector2();\n\nclass Sprite extends Object3D {\n  constructor(material) {\n    super();\n    this.type = 'Sprite';\n\n    if (_geometry === undefined) {\n      _geometry = new BufferGeometry();\n      const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);\n      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n\n      _geometry.setIndex([0, 1, 2, 0, 2, 3]);\n\n      _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n\n      _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n    }\n\n    this.geometry = _geometry;\n    this.material = material !== undefined ? material : new SpriteMaterial();\n    this.center = new Vector2(0.5, 0.5);\n  }\n\n  raycast(raycaster, intersects) {\n    if (raycaster.camera === null) {\n      console.error('THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.');\n    }\n\n    _worldScale.setFromMatrixScale(this.matrixWorld);\n\n    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);\n\n    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);\n\n    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);\n\n    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {\n      _worldScale.multiplyScalar(-_mvPosition.z);\n    }\n\n    const rotation = this.material.rotation;\n    let sin, cos;\n\n    if (rotation !== 0) {\n      cos = Math.cos(rotation);\n      sin = Math.sin(rotation);\n    }\n\n    const center = this.center;\n    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\n    _uvA.set(0, 0);\n\n    _uvB.set(1, 0);\n\n    _uvC.set(1, 1); // check first triangle\n\n\n    let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);\n\n    if (intersect === null) {\n      // check second triangle\n      transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\n      _uvB.set(0, 1);\n\n      intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);\n\n      if (intersect === null) {\n        return;\n      }\n    }\n\n    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);\n    if (distance < raycaster.near || distance > raycaster.far) return;\n    intersects.push({\n      distance: distance,\n      point: _intersectPoint.clone(),\n      uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),\n      face: null,\n      object: this\n    });\n  }\n\n  copy(source) {\n    super.copy(source);\n    if (source.center !== undefined) this.center.copy(source.center);\n    this.material = source.material;\n    return this;\n  }\n\n}\n\nSprite.prototype.isSprite = true;\n\nfunction transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {\n  // compute position in camera space\n  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero\n\n\n  if (sin !== undefined) {\n    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;\n    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;\n  } else {\n    _rotatedPosition.copy(_alignedPosition);\n  }\n\n  vertexPosition.copy(mvPosition);\n  vertexPosition.x += _rotatedPosition.x;\n  vertexPosition.y += _rotatedPosition.y; // transform to world space\n\n  vertexPosition.applyMatrix4(_viewWorldMatrix);\n}\n\nexport { Sprite };","map":null,"metadata":{},"sourceType":"module"}