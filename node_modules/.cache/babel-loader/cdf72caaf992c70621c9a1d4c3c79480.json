{"ast":null,"code":"import _asyncToGenerator from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"/Users/robertrinearson/Documents/blockchain/lfg/cyberdeck-twitter/node_modules/@babel/runtime/regenerator/index.js\";\nimport { ArrayCamera } from '../../cameras/ArrayCamera.js';\nimport { EventDispatcher } from '../../core/EventDispatcher.js';\nimport { PerspectiveCamera } from '../../cameras/PerspectiveCamera.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { WebGLAnimation } from '../webgl/WebGLAnimation.js';\nimport { WebGLRenderTarget } from '../WebGLRenderTarget.js';\nimport { WebXRController } from './WebXRController.js';\nimport { DepthTexture } from '../../textures/DepthTexture.js';\nimport { WebGLMultisampleRenderTarget } from '../WebGLMultisampleRenderTarget.js';\nimport { DepthFormat, DepthStencilFormat, RGBAFormat, sRGBEncoding, UnsignedByteType, UnsignedShortType, UnsignedInt248Type } from '../../constants.js';\n\nvar WebXRManager = /*#__PURE__*/function (_EventDispatcher) {\n  _inherits(WebXRManager, _EventDispatcher);\n\n  var _super = _createSuper(WebXRManager);\n\n  function WebXRManager(renderer, gl) {\n    var _this;\n\n    _classCallCheck(this, WebXRManager);\n\n    _this = _super.call(this);\n\n    var scope = _assertThisInitialized(_this);\n\n    var session = null;\n    var framebufferScaleFactor = 1.0;\n    var referenceSpace = null;\n    var referenceSpaceType = 'local-floor';\n    var hasMultisampledRenderToTexture = renderer.extensions.has('WEBGL_multisampled_render_to_texture');\n    var pose = null;\n    var glBinding = null;\n    var glProjLayer = null;\n    var glBaseLayer = null;\n    var isMultisample = false;\n    var xrFrame = null;\n    var attributes = gl.getContextAttributes();\n    var initialRenderTarget = null;\n    var newRenderTarget = null;\n    var controllers = [];\n    var inputSourcesMap = new Map(); //\n\n    var cameraL = new PerspectiveCamera();\n    cameraL.layers.enable(1);\n    cameraL.viewport = new Vector4();\n    var cameraR = new PerspectiveCamera();\n    cameraR.layers.enable(2);\n    cameraR.viewport = new Vector4();\n    var cameras = [cameraL, cameraR];\n    var cameraVR = new ArrayCamera();\n    cameraVR.layers.enable(1);\n    cameraVR.layers.enable(2);\n    var _currentDepthNear = null;\n    var _currentDepthFar = null; //\n\n    _this.cameraAutoUpdate = true;\n    _this.enabled = false;\n    _this.isPresenting = false;\n\n    _this.getController = function (index) {\n      var controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getTargetRaySpace();\n    };\n\n    _this.getControllerGrip = function (index) {\n      var controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getGripSpace();\n    };\n\n    _this.getHand = function (index) {\n      var controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getHandSpace();\n    }; //\n\n\n    function onSessionEvent(event) {\n      var controller = inputSourcesMap.get(event.inputSource);\n\n      if (controller) {\n        controller.dispatchEvent({\n          type: event.type,\n          data: event.inputSource\n        });\n      }\n    }\n\n    function onSessionEnd() {\n      inputSourcesMap.forEach(function (controller, inputSource) {\n        controller.disconnect(inputSource);\n      });\n      inputSourcesMap.clear();\n      _currentDepthNear = null;\n      _currentDepthFar = null; // restore framebuffer/rendering state\n\n      renderer.setRenderTarget(initialRenderTarget);\n      glBaseLayer = null;\n      glProjLayer = null;\n      glBinding = null;\n      session = null;\n      newRenderTarget = null; //\n\n      animation.stop();\n      scope.isPresenting = false;\n      scope.dispatchEvent({\n        type: 'sessionend'\n      });\n    }\n\n    _this.setFramebufferScaleFactor = function (value) {\n      framebufferScaleFactor = value;\n\n      if (scope.isPresenting === true) {\n        console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');\n      }\n    };\n\n    _this.setReferenceSpaceType = function (value) {\n      referenceSpaceType = value;\n\n      if (scope.isPresenting === true) {\n        console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');\n      }\n    };\n\n    _this.getReferenceSpace = function () {\n      return referenceSpace;\n    };\n\n    _this.getBaseLayer = function () {\n      return glProjLayer !== null ? glProjLayer : glBaseLayer;\n    };\n\n    _this.getBinding = function () {\n      return glBinding;\n    };\n\n    _this.getFrame = function () {\n      return xrFrame;\n    };\n\n    _this.getSession = function () {\n      return session;\n    };\n\n    _this.setSession = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {\n        var layerInit, depthFormat, depthType, glDepthFormat, projectionlayerInit;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                session = value;\n\n                if (!(session !== null)) {\n                  _context.next = 24;\n                  break;\n                }\n\n                initialRenderTarget = renderer.getRenderTarget();\n                session.addEventListener('select', onSessionEvent);\n                session.addEventListener('selectstart', onSessionEvent);\n                session.addEventListener('selectend', onSessionEvent);\n                session.addEventListener('squeeze', onSessionEvent);\n                session.addEventListener('squeezestart', onSessionEvent);\n                session.addEventListener('squeezeend', onSessionEvent);\n                session.addEventListener('end', onSessionEnd);\n                session.addEventListener('inputsourceschange', onInputSourcesChange);\n\n                if (!(attributes.xrCompatible !== true)) {\n                  _context.next = 14;\n                  break;\n                }\n\n                _context.next = 14;\n                return gl.makeXRCompatible();\n\n              case 14:\n                if (session.renderState.layers === undefined || renderer.capabilities.isWebGL2 === false) {\n                  layerInit = {\n                    antialias: session.renderState.layers === undefined ? attributes.antialias : true,\n                    alpha: attributes.alpha,\n                    depth: attributes.depth,\n                    stencil: attributes.stencil,\n                    framebufferScaleFactor: framebufferScaleFactor\n                  };\n                  glBaseLayer = new XRWebGLLayer(session, gl, layerInit);\n                  session.updateRenderState({\n                    baseLayer: glBaseLayer\n                  });\n                  newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {\n                    format: RGBAFormat,\n                    type: UnsignedByteType,\n                    encoding: renderer.outputEncoding\n                  });\n                } else {\n                  isMultisample = attributes.antialias;\n                  depthFormat = null;\n                  depthType = null;\n                  glDepthFormat = null;\n\n                  if (attributes.depth) {\n                    glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\n                    depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;\n                    depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;\n                  }\n\n                  projectionlayerInit = {\n                    colorFormat: renderer.outputEncoding === sRGBEncoding ? gl.SRGB8_ALPHA8 : gl.RGBA8,\n                    depthFormat: glDepthFormat,\n                    scaleFactor: framebufferScaleFactor\n                  };\n                  glBinding = new XRWebGLBinding(session, gl);\n                  glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);\n                  session.updateRenderState({\n                    layers: [glProjLayer]\n                  });\n\n                  if (isMultisample) {\n                    newRenderTarget = new WebGLMultisampleRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {\n                      format: RGBAFormat,\n                      type: UnsignedByteType,\n                      depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),\n                      stencilBuffer: attributes.stencil,\n                      ignoreDepth: glProjLayer.ignoreDepthValues,\n                      useRenderToTexture: hasMultisampledRenderToTexture,\n                      encoding: renderer.outputEncoding\n                    });\n                  } else {\n                    newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {\n                      format: RGBAFormat,\n                      type: UnsignedByteType,\n                      depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),\n                      stencilBuffer: attributes.stencil,\n                      ignoreDepth: glProjLayer.ignoreDepthValues,\n                      encoding: renderer.outputEncoding\n                    });\n                  }\n                }\n\n                newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278\n                // Set foveation to maximum.\n\n                this.setFoveation(1.0);\n                _context.next = 19;\n                return session.requestReferenceSpace(referenceSpaceType);\n\n              case 19:\n                referenceSpace = _context.sent;\n                animation.setContext(session);\n                animation.start();\n                scope.isPresenting = true;\n                scope.dispatchEvent({\n                  type: 'sessionstart'\n                });\n\n              case 24:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    function onInputSourcesChange(event) {\n      var inputSources = session.inputSources; // Assign inputSources to available controllers\n\n      for (var i = 0; i < controllers.length; i++) {\n        inputSourcesMap.set(inputSources[i], controllers[i]);\n      } // Notify disconnected\n\n\n      for (var _i = 0; _i < event.removed.length; _i++) {\n        var inputSource = event.removed[_i];\n        var controller = inputSourcesMap.get(inputSource);\n\n        if (controller) {\n          controller.dispatchEvent({\n            type: 'disconnected',\n            data: inputSource\n          });\n          inputSourcesMap.delete(inputSource);\n        }\n      } // Notify connected\n\n\n      for (var _i2 = 0; _i2 < event.added.length; _i2++) {\n        var _inputSource = event.added[_i2];\n\n        var _controller = inputSourcesMap.get(_inputSource);\n\n        if (_controller) {\n          _controller.dispatchEvent({\n            type: 'connected',\n            data: _inputSource\n          });\n        }\n      }\n    } //\n\n\n    var cameraLPos = new Vector3();\n    var cameraRPos = new Vector3();\n    /**\n     * Assumes 2 cameras that are parallel and share an X-axis, and that\n     * the cameras' projection and world matrices have already been set.\n     * And that near and far planes are identical for both cameras.\n     * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n     */\n\n    function setProjectionFromUnion(camera, cameraL, cameraR) {\n      cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);\n      cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);\n      var ipd = cameraLPos.distanceTo(cameraRPos);\n      var projL = cameraL.projectionMatrix.elements;\n      var projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and\n      // most likely identical top and bottom frustum extents.\n      // Use the left camera for these values.\n\n      var near = projL[14] / (projL[10] - 1);\n      var far = projL[14] / (projL[10] + 1);\n      var topFov = (projL[9] + 1) / projL[5];\n      var bottomFov = (projL[9] - 1) / projL[5];\n      var leftFov = (projL[8] - 1) / projL[0];\n      var rightFov = (projR[8] + 1) / projR[0];\n      var left = near * leftFov;\n      var right = near * rightFov; // Calculate the new camera's position offset from the\n      // left camera. xOffset should be roughly half `ipd`.\n\n      var zOffset = ipd / (-leftFov + rightFov);\n      var xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?\n\n      cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);\n      camera.translateX(xOffset);\n      camera.translateZ(zOffset);\n      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale\n      // the values so that the near plane's position does not change in world space,\n      // although must now be relative to the new union camera.\n\n      var near2 = near + zOffset;\n      var far2 = far + zOffset;\n      var left2 = left - xOffset;\n      var right2 = right + (ipd - xOffset);\n      var top2 = topFov * far / far2 * near2;\n      var bottom2 = bottomFov * far / far2 * near2;\n      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);\n    }\n\n    function updateCamera(camera, parent) {\n      if (parent === null) {\n        camera.matrixWorld.copy(camera.matrix);\n      } else {\n        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);\n      }\n\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n    }\n\n    _this.updateCamera = function (camera) {\n      if (session === null) return;\n      cameraVR.near = cameraR.near = cameraL.near = camera.near;\n      cameraVR.far = cameraR.far = cameraL.far = camera.far;\n\n      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {\n        // Note that the new renderState won't apply until the next frame. See #18320\n        session.updateRenderState({\n          depthNear: cameraVR.near,\n          depthFar: cameraVR.far\n        });\n        _currentDepthNear = cameraVR.near;\n        _currentDepthFar = cameraVR.far;\n      }\n\n      var parent = camera.parent;\n      var cameras = cameraVR.cameras;\n      updateCamera(cameraVR, parent);\n\n      for (var i = 0; i < cameras.length; i++) {\n        updateCamera(cameras[i], parent);\n      }\n\n      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale); // update user camera and its children\n\n      camera.position.copy(cameraVR.position);\n      camera.quaternion.copy(cameraVR.quaternion);\n      camera.scale.copy(cameraVR.scale);\n      camera.matrix.copy(cameraVR.matrix);\n      camera.matrixWorld.copy(cameraVR.matrixWorld);\n      var children = camera.children;\n\n      for (var _i3 = 0, l = children.length; _i3 < l; _i3++) {\n        children[_i3].updateMatrixWorld(true);\n      } // update projection matrix for proper view frustum culling\n\n\n      if (cameras.length === 2) {\n        setProjectionFromUnion(cameraVR, cameraL, cameraR);\n      } else {\n        // assume single camera setup (AR)\n        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);\n      }\n    };\n\n    _this.getCamera = function () {\n      return cameraVR;\n    };\n\n    _this.getFoveation = function () {\n      if (glProjLayer !== null) {\n        return glProjLayer.fixedFoveation;\n      }\n\n      if (glBaseLayer !== null) {\n        return glBaseLayer.fixedFoveation;\n      }\n\n      return undefined;\n    };\n\n    _this.setFoveation = function (foveation) {\n      // 0 = no foveation = full resolution\n      // 1 = maximum foveation = the edges render at lower resolution\n      if (glProjLayer !== null) {\n        glProjLayer.fixedFoveation = foveation;\n      }\n\n      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {\n        glBaseLayer.fixedFoveation = foveation;\n      }\n    }; // Animation Loop\n\n\n    var onAnimationFrameCallback = null;\n\n    function onAnimationFrame(time, frame) {\n      pose = frame.getViewerPose(referenceSpace);\n      xrFrame = frame;\n\n      if (pose !== null) {\n        var views = pose.views;\n\n        if (glBaseLayer !== null) {\n          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);\n          renderer.setRenderTarget(newRenderTarget);\n        }\n\n        var cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list\n\n        if (views.length !== cameraVR.cameras.length) {\n          cameraVR.cameras.length = 0;\n          cameraVRNeedsUpdate = true;\n        }\n\n        for (var i = 0; i < views.length; i++) {\n          var view = views[i];\n          var viewport = null;\n\n          if (glBaseLayer !== null) {\n            viewport = glBaseLayer.getViewport(view);\n          } else {\n            var glSubImage = glBinding.getViewSubImage(glProjLayer, view);\n            viewport = glSubImage.viewport; // For side-by-side projection, we only produce a single texture for both eyes.\n\n            if (i === 0) {\n              renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);\n              renderer.setRenderTarget(newRenderTarget);\n            }\n          }\n\n          var camera = cameras[i];\n          camera.matrix.fromArray(view.transform.matrix);\n          camera.projectionMatrix.fromArray(view.projectionMatrix);\n          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);\n\n          if (i === 0) {\n            cameraVR.matrix.copy(camera.matrix);\n          }\n\n          if (cameraVRNeedsUpdate === true) {\n            cameraVR.cameras.push(camera);\n          }\n        }\n      } //\n\n\n      var inputSources = session.inputSources;\n\n      for (var _i4 = 0; _i4 < controllers.length; _i4++) {\n        var controller = controllers[_i4];\n        var inputSource = inputSources[_i4];\n        controller.update(inputSource, frame, referenceSpace);\n      }\n\n      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);\n      xrFrame = null;\n    }\n\n    var animation = new WebGLAnimation();\n    animation.setAnimationLoop(onAnimationFrame);\n\n    _this.setAnimationLoop = function (callback) {\n      onAnimationFrameCallback = callback;\n    };\n\n    _this.dispose = function () {};\n\n    return _this;\n  }\n\n  return _createClass(WebXRManager);\n}(EventDispatcher);\n\nexport { WebXRManager };","map":null,"metadata":{},"sourceType":"module"}