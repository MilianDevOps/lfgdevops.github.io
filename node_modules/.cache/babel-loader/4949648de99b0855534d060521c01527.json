{"ast":null,"code":"import { Matrix4, Object3D, Quaternion, Vector3 } from 'three';\n/**\n * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs\n */\n\nconst _position = new Vector3();\n\nconst _quaternion = new Quaternion();\n\nconst _scale = new Vector3();\n\nclass CSS3DObject extends Object3D {\n  constructor() {\n    let element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.createElement('div');\n    super();\n    this.element = element;\n    this.element.style.position = 'absolute';\n    this.element.style.pointerEvents = 'auto';\n    this.element.style.userSelect = 'none';\n    this.element.setAttribute('draggable', false);\n    this.addEventListener('removed', function () {\n      this.traverse(function (object) {\n        if (object.element instanceof Element && object.element.parentNode !== null) {\n          object.element.parentNode.removeChild(object.element);\n        }\n      });\n    });\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.element = source.element.cloneNode(true);\n    return this;\n  }\n\n}\n\nCSS3DObject.prototype.isCSS3DObject = true;\n\nclass CSS3DSprite extends CSS3DObject {\n  constructor(element) {\n    super(element);\n    this.rotation2D = 0;\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.rotation2D = source.rotation2D;\n    return this;\n  }\n\n}\n\nCSS3DSprite.prototype.isCSS3DSprite = true; //\n\nconst _matrix = new Matrix4();\n\nconst _matrix2 = new Matrix4();\n\nclass CSS3DRenderer {\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const _this = this;\n\n    let _width, _height;\n\n    let _widthHalf, _heightHalf;\n\n    const cache = {\n      camera: {\n        fov: 0,\n        style: ''\n      },\n      objects: new WeakMap()\n    };\n    const domElement = parameters.element !== undefined ? parameters.element : document.createElement('div');\n    domElement.style.overflow = 'hidden';\n    this.domElement = domElement;\n    const cameraElement = document.createElement('div');\n    cameraElement.style.transformStyle = 'preserve-3d';\n    cameraElement.style.pointerEvents = 'none';\n    domElement.appendChild(cameraElement);\n\n    this.getSize = function () {\n      return {\n        width: _width,\n        height: _height\n      };\n    };\n\n    this.render = function (scene, camera) {\n      const fov = camera.projectionMatrix.elements[5] * _heightHalf;\n\n      if (cache.camera.fov !== fov) {\n        domElement.style.perspective = camera.isPerspectiveCamera ? fov + 'px' : '';\n        cache.camera.fov = fov;\n      }\n\n      if (scene.autoUpdate === true) scene.updateMatrixWorld();\n      if (camera.parent === null) camera.updateMatrixWorld();\n      let tx, ty;\n\n      if (camera.isOrthographicCamera) {\n        tx = -(camera.right + camera.left) / 2;\n        ty = (camera.top + camera.bottom) / 2;\n      }\n\n      const cameraCSSMatrix = camera.isOrthographicCamera ? 'scale(' + fov + ')' + 'translate(' + epsilon(tx) + 'px,' + epsilon(ty) + 'px)' + getCameraCSSMatrix(camera.matrixWorldInverse) : 'translateZ(' + fov + 'px)' + getCameraCSSMatrix(camera.matrixWorldInverse);\n      const style = cameraCSSMatrix + 'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';\n\n      if (cache.camera.style !== style) {\n        cameraElement.style.transform = style;\n        cache.camera.style = style;\n      }\n\n      renderObject(scene, scene, camera, cameraCSSMatrix);\n    };\n\n    this.setSize = function (width, height) {\n      _width = width;\n      _height = height;\n      _widthHalf = _width / 2;\n      _heightHalf = _height / 2;\n      domElement.style.width = width + 'px';\n      domElement.style.height = height + 'px';\n      cameraElement.style.width = width + 'px';\n      cameraElement.style.height = height + 'px';\n    };\n\n    function epsilon(value) {\n      return Math.abs(value) < 1e-10 ? 0 : value;\n    }\n\n    function getCameraCSSMatrix(matrix) {\n      const elements = matrix.elements;\n      return 'matrix3d(' + epsilon(elements[0]) + ',' + epsilon(-elements[1]) + ',' + epsilon(elements[2]) + ',' + epsilon(elements[3]) + ',' + epsilon(elements[4]) + ',' + epsilon(-elements[5]) + ',' + epsilon(elements[6]) + ',' + epsilon(elements[7]) + ',' + epsilon(elements[8]) + ',' + epsilon(-elements[9]) + ',' + epsilon(elements[10]) + ',' + epsilon(elements[11]) + ',' + epsilon(elements[12]) + ',' + epsilon(-elements[13]) + ',' + epsilon(elements[14]) + ',' + epsilon(elements[15]) + ')';\n    }\n\n    function getObjectCSSMatrix(matrix) {\n      const elements = matrix.elements;\n      const matrix3d = 'matrix3d(' + epsilon(elements[0]) + ',' + epsilon(elements[1]) + ',' + epsilon(elements[2]) + ',' + epsilon(elements[3]) + ',' + epsilon(-elements[4]) + ',' + epsilon(-elements[5]) + ',' + epsilon(-elements[6]) + ',' + epsilon(-elements[7]) + ',' + epsilon(elements[8]) + ',' + epsilon(elements[9]) + ',' + epsilon(elements[10]) + ',' + epsilon(elements[11]) + ',' + epsilon(elements[12]) + ',' + epsilon(elements[13]) + ',' + epsilon(elements[14]) + ',' + epsilon(elements[15]) + ')';\n      return 'translate(-50%,-50%)' + matrix3d;\n    }\n\n    function renderObject(object, scene, camera, cameraCSSMatrix) {\n      if (object.isCSS3DObject) {\n        const visible = object.visible && object.layers.test(camera.layers);\n        object.element.style.display = visible ? '' : 'none'; // only getObjectCSSMatrix when object.visible\n\n        if (visible) {\n          object.onBeforeRender(_this, scene, camera);\n          let style;\n\n          if (object.isCSS3DSprite) {\n            // http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/\n            _matrix.copy(camera.matrixWorldInverse);\n\n            _matrix.transpose();\n\n            if (object.rotation2D !== 0) _matrix.multiply(_matrix2.makeRotationZ(object.rotation2D));\n            object.matrixWorld.decompose(_position, _quaternion, _scale);\n\n            _matrix.setPosition(_position);\n\n            _matrix.scale(_scale);\n\n            _matrix.elements[3] = 0;\n            _matrix.elements[7] = 0;\n            _matrix.elements[11] = 0;\n            _matrix.elements[15] = 1;\n            style = getObjectCSSMatrix(_matrix);\n          } else {\n            style = getObjectCSSMatrix(object.matrixWorld);\n          }\n\n          const element = object.element;\n          const cachedObject = cache.objects.get(object);\n\n          if (cachedObject === undefined || cachedObject.style !== style) {\n            element.style.transform = style;\n            const objectData = {\n              style: style\n            };\n            cache.objects.set(object, objectData);\n          }\n\n          if (element.parentNode !== cameraElement) {\n            cameraElement.appendChild(element);\n          }\n\n          object.onAfterRender(_this, scene, camera);\n        }\n      }\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        renderObject(object.children[i], scene, camera, cameraCSSMatrix);\n      }\n    }\n  }\n\n}\n\nexport { CSS3DObject, CSS3DSprite, CSS3DRenderer };","map":null,"metadata":{},"sourceType":"module"}