{"ast":null,"code":"import { Vector3 } from './Vector3.js';\n/**\n * Primary reference:\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\n *\n * Secondary reference:\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\n */\n// 3-band SH defined by 9 coefficients\n\nclass SphericalHarmonics3 {\n  constructor() {\n    this.coefficients = [];\n\n    for (let i = 0; i < 9; i++) {\n      this.coefficients.push(new Vector3());\n    }\n  }\n\n  set(coefficients) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].copy(coefficients[i]);\n    }\n\n    return this;\n  }\n\n  zero() {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].set(0, 0, 0);\n    }\n\n    return this;\n  } // get the radiance in the direction of the normal\n  // target is a Vector3\n\n\n  getAt(normal, target) {\n    // normal is assumed to be unit length\n    const x = normal.x,\n          y = normal.y,\n          z = normal.z;\n    const coeff = this.coefficients; // band 0\n\n    target.copy(coeff[0]).multiplyScalar(0.282095); // band 1\n\n    target.addScaledVector(coeff[1], 0.488603 * y);\n    target.addScaledVector(coeff[2], 0.488603 * z);\n    target.addScaledVector(coeff[3], 0.488603 * x); // band 2\n\n    target.addScaledVector(coeff[4], 1.092548 * (x * y));\n    target.addScaledVector(coeff[5], 1.092548 * (y * z));\n    target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));\n    target.addScaledVector(coeff[7], 1.092548 * (x * z));\n    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));\n    return target;\n  } // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n  // target is a Vector3\n  // https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\n\n  getIrradianceAt(normal, target) {\n    // normal is assumed to be unit length\n    const x = normal.x,\n          y = normal.y,\n          z = normal.z;\n    const coeff = this.coefficients; // band 0\n\n    target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095\n    // band 1\n\n    target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603\n\n    target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);\n    target.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2\n\n    target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548\n\n    target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);\n    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3\n\n    target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);\n    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274\n\n    return target;\n  }\n\n  add(sh) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].add(sh.coefficients[i]);\n    }\n\n    return this;\n  }\n\n  addScaledSH(sh, s) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].addScaledVector(sh.coefficients[i], s);\n    }\n\n    return this;\n  }\n\n  scale(s) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].multiplyScalar(s);\n    }\n\n    return this;\n  }\n\n  lerp(sh, alpha) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].lerp(sh.coefficients[i], alpha);\n    }\n\n    return this;\n  }\n\n  equals(sh) {\n    for (let i = 0; i < 9; i++) {\n      if (!this.coefficients[i].equals(sh.coefficients[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  copy(sh) {\n    return this.set(sh.coefficients);\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  fromArray(array) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const coefficients = this.coefficients;\n\n    for (let i = 0; i < 9; i++) {\n      coefficients[i].fromArray(array, offset + i * 3);\n    }\n\n    return this;\n  }\n\n  toArray() {\n    let array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const coefficients = this.coefficients;\n\n    for (let i = 0; i < 9; i++) {\n      coefficients[i].toArray(array, offset + i * 3);\n    }\n\n    return array;\n  } // evaluate the basis functions\n  // shBasis is an Array[ 9 ]\n\n\n  static getBasisAt(normal, shBasis) {\n    // normal is assumed to be unit length\n    const x = normal.x,\n          y = normal.y,\n          z = normal.z; // band 0\n\n    shBasis[0] = 0.282095; // band 1\n\n    shBasis[1] = 0.488603 * y;\n    shBasis[2] = 0.488603 * z;\n    shBasis[3] = 0.488603 * x; // band 2\n\n    shBasis[4] = 1.092548 * x * y;\n    shBasis[5] = 1.092548 * y * z;\n    shBasis[6] = 0.315392 * (3 * z * z - 1);\n    shBasis[7] = 1.092548 * x * z;\n    shBasis[8] = 0.546274 * (x * x - y * y);\n  }\n\n}\n\nSphericalHarmonics3.prototype.isSphericalHarmonics3 = true;\nexport { SphericalHarmonics3 };","map":null,"metadata":{},"sourceType":"module"}