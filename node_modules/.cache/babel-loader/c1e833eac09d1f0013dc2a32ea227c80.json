{"ast":null,"code":"import { RGBAFormat, FloatType } from '../constants.js';\nimport { Bone } from './Bone.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { DataTexture } from '../textures/DataTexture.js';\nimport * as MathUtils from '../math/MathUtils.js';\n\nconst _offsetMatrix = /*@__PURE__*/new Matrix4();\n\nconst _identityMatrix = /*@__PURE__*/new Matrix4();\n\nclass Skeleton {\n  constructor() {\n    let bones = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let boneInverses = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    this.uuid = MathUtils.generateUUID();\n    this.bones = bones.slice(0);\n    this.boneInverses = boneInverses;\n    this.boneMatrices = null;\n    this.boneTexture = null;\n    this.boneTextureSize = 0;\n    this.frame = -1;\n    this.init();\n  }\n\n  init() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    this.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary\n\n    if (boneInverses.length === 0) {\n      this.calculateInverses();\n    } else {\n      // handle special case\n      if (bones.length !== boneInverses.length) {\n        console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');\n        this.boneInverses = [];\n\n        for (let i = 0, il = this.bones.length; i < il; i++) {\n          this.boneInverses.push(new Matrix4());\n        }\n      }\n    }\n  }\n\n  calculateInverses() {\n    this.boneInverses.length = 0;\n\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const inverse = new Matrix4();\n\n      if (this.bones[i]) {\n        inverse.copy(this.bones[i].matrixWorld).invert();\n      }\n\n      this.boneInverses.push(inverse);\n    }\n  }\n\n  pose() {\n    // recover the bind-time world matrices\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n\n      if (bone) {\n        bone.matrixWorld.copy(this.boneInverses[i]).invert();\n      }\n    } // compute the local matrices, positions, rotations and scales\n\n\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n\n      if (bone) {\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(bone.matrixWorld);\n        } else {\n          bone.matrix.copy(bone.matrixWorld);\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n      }\n    }\n  }\n\n  update() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    const boneMatrices = this.boneMatrices;\n    const boneTexture = this.boneTexture; // flatten bone matrices to array\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      // compute the offset between the current and the original transform\n      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;\n\n      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);\n\n      _offsetMatrix.toArray(boneMatrices, i * 16);\n    }\n\n    if (boneTexture !== null) {\n      boneTexture.needsUpdate = true;\n    }\n  }\n\n  clone() {\n    return new Skeleton(this.bones, this.boneInverses);\n  }\n\n  computeBoneTexture() {\n    // layout (1 matrix = 4 pixels)\n    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n    //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n    //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n    //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n    //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n    let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix\n\n    size = MathUtils.ceilPowerOfTwo(size);\n    size = Math.max(size, 4);\n    const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel\n\n    boneMatrices.set(this.boneMatrices); // copy current values\n\n    const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\n    boneTexture.needsUpdate = true;\n    this.boneMatrices = boneMatrices;\n    this.boneTexture = boneTexture;\n    this.boneTextureSize = size;\n    return this;\n  }\n\n  getBoneByName(name) {\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n\n      if (bone.name === name) {\n        return bone;\n      }\n    }\n\n    return undefined;\n  }\n\n  dispose() {\n    if (this.boneTexture !== null) {\n      this.boneTexture.dispose();\n      this.boneTexture = null;\n    }\n  }\n\n  fromJSON(json, bones) {\n    this.uuid = json.uuid;\n\n    for (let i = 0, l = json.bones.length; i < l; i++) {\n      const uuid = json.bones[i];\n      let bone = bones[uuid];\n\n      if (bone === undefined) {\n        console.warn('THREE.Skeleton: No bone found with UUID:', uuid);\n        bone = new Bone();\n      }\n\n      this.bones.push(bone);\n      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));\n    }\n\n    this.init();\n    return this;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Skeleton',\n        generator: 'Skeleton.toJSON'\n      },\n      bones: [],\n      boneInverses: []\n    };\n    data.uuid = this.uuid;\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n\n    for (let i = 0, l = bones.length; i < l; i++) {\n      const bone = bones[i];\n      data.bones.push(bone.uuid);\n      const boneInverse = boneInverses[i];\n      data.boneInverses.push(boneInverse.toArray());\n    }\n\n    return data;\n  }\n\n}\n\nexport { Skeleton };","map":null,"metadata":{},"sourceType":"module"}